<!--
 * @Author: chenfangxu
 * @Date: 2020-10-05 20:22:20
 * @LastEditTime: 2020-10-23 08:30:57
 * @LastEditors: chenfangxu
 * @Description: Shell 脚本
 * @FilePath: /front/assistive-tools/shell/script.md
-->

# Shell 脚本

Shell 脚本（shell script），是一种为 Shell 编写的脚本程序，一般文件后缀为 `.sh`。

## 脚本解释器

`#!` 是一个约定的标记，它告诉系统这个脚本需要什么解释器来运行，即使用哪一种 shell。`#!`被称为[shebang（也称为 Hashbang）](https://zh.wikipedia.org/wiki/Shebang),例如使用 bash：`#! /bin/bash`

新建一个 test.sh 的文件，内容如下：

```
#!/bin/bash

echo "Hello World!"
```

## 运行 Shell 脚本

### 第一种方式：作为可执行程序

1、当前 test.sh 是没有可执行权限的，首先使脚本文件具有执行权限。

```
# 使脚本文件具有执行权限
chmod +x ./test.sh
```

2、执行脚本

```
# 执行脚本，需注意要加目录的标识
./test.sh

# 也可以用 source 来执行脚本，跟上面的写法是等价的，但是不需要脚本具有执行权限
source ./test.sh
```

**注意：一定要写成 ./test/sh ,而不是 test.sh 。运行其他二进制的程序也是一样，直接写 test.sh，Linux 系统回去 PATH 中寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin, /usr/sbin 等在 PATH 中。你的当前目录通常不在 PATH 中，所以写成 test.sh 是会找不到命令的，要用./test.sh 告诉系统，就在当前目录找。**

通过这种方式运行 bash 脚本，第一行一定要写对，好让系统（Shell 程序）查找到正确的解释器。如果是使用标准默认的 shell，可以省去第一行。

### 作为解释器参数

直接运行解释器，其参数就是 Shell 脚本的文件名。

```
/bin/bash test.sh
```

这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。

## 语法

### 1、注释

- 单行注释：以 `#` 开头，到行尾结束。
- 多行注释：以 `:<<EOF` 开头，到 `EOF` 结束

```
# 这是单行注释

:<<EOF
这是多行注释
这是多行注释
EOF
```

### 2、变量

#### 命名规则

- 命名只能使用英文字母，数字下划线，首个字符不能以数字开头
- 不能使用标点符号，中间不能有空格，如果有空格，必须使用单引号或双引号
- 不能使用 bash 中的关键字

#### 变量类型

- **局部变量**：局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。
- **环境变量**：环境变量是从父进程中继承而来的变量，对当前 Shell 会话内所有的程序和脚本都可见。创建它们跟创建局部变量类似，但使用的是 `export` 关键字，shell 脚本也可以定义环境变量。
- **shell 变量**：shell 变量是由 shell 程序设置的特殊变量。shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 shell 的正常运行。

#### 变量语法

1、声明变量

可以使用等号操作符为变量赋值：`varName=value`，varName 是变量名，value 是赋值给变量的值。

变量名的命名规则：

- 首字母必须为字母（a-z,A-Z）
- 中间不能有空格，可以使用下划线
- 不能使用标点符号
- 不能使用 bash 关键字

```
#!/bin/bash

fruit=apple
count=5
```

**注意：`varName=value`的等号两边没有空格**

2、访问变量

访问变量的语法形式为：`${varName}` 和 `$varName`，变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界（推荐加花括号）。

```
#!/bin/bash

fruit=apple
count=5
echo "We have $count ${fruit}s"
#输出：We have 5 apples
```

因为 Shell 使用空白字符来分隔单词，所以上面的例子中需要加上花括号来告诉 Shell 这里的变量名是 fruit，而不是 fruits

**注意：使用单引号时，变量不会被扩展(expand)，仍依照原样显示。这意味着 `echo '$var'`会显示 \$var。使用双引号时，如果\$var 已经定义过，那么 `echo $var`会显示出该变量的值，如果没有定义过，则什么都不显示。**

3、只读变量

使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变

```
#!/bin/bash

fruit=apple
echo $fruit
readonly fruit
#fruit=banana  #如果放开注释，执行时会报错
```

4、删除变量

使用 unset 命令可以删除变量，变量被删除后不能再次使用。**unset 命令不能删除只读变量**

```
#!/bin/bash

fruit=apple
echo $fruit
#输出： apple

unset fruit
echo $fruit
#输出： (空)
```

#### Shell 特殊变量

上面讲过变量名的命名规则，但是还有一些包含其他字符的变量有特殊含义，这样的变量被称为特殊变量。

| 变量 | 含义                                                                        |
| :--- | :-------------------------------------------------------------------------- |
| \$0  | 当前脚本的文件名                                                            |
| \$n  | 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是\$1 |
| \$#  | 传递给脚本或函数的参数个数                                                  |
| \$\* | 传递给脚本或函数的所有参数                                                  |
| \$@  | 传递给脚本或函数的所有参数，被双引号（""）包含时，与\$\*稍有不同            |
| \$?  | 上个命令的退出状态，或函数的返回值                                          |
| \$\$ | 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID              |

> 命令行参数：运行脚本时传递给脚本的参数成为命令行参数，命令行参数用\$n 表示。

```
#!/bin/bash

# ./test.sh

echo "文件名：$0"
echo "第一个命令行参数：$1"
echo "第二个命令行参数：$2"
echo "传入的全部参数：$@"
echo "传入的全部参数：$*"
echo "全部参数的数量：$#"
```

执行命令：`./test.sh Linux Shell`，结果为：

```
文件名：./test.sh
第一个命令行参数：Linux
第二个命令行参数：Shell
传入的全部参数：Linux Shell
传入的全部参数：Linux Shell
全部参数的数量：2
```

\$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败会返回 1。\$?也可以表示函数的返回值。

### 3、字符串

#### 字符串引号

shell 字符串可以使用单引号 `''` ，也可以使用双引号`"" ` ， 也可以不用引号。

- 单引号：不识别变量，单引号中间不能出现单独的单引号（使用转义字符转义也不行），可以成对出现实现字符串拼接。

```
name='world'

before='hello,'${name}'!' #使用单引号拼接字符串
after='hello,${name}!'  #单引号中变量不解析

echo ${before}_${after}
# 输出：hello,world!_hello,${name}!
```

- 双引号：可以识别变量，双引号中可以出现用转义字符转义的双引号

```
name="\"shell\""  #双引号内允许出现被转义的双引号

before="hello,"${name}"!" #使用双引号拼接字符串
after="hello,${name}!" #双引号中变量会解析

echo ${before}_${after}
# 输出：hello,"shell"!_hello,"shell"!
```

> 设置一个字符串变量，下面的都是对这个变量的操作

```
file=/dir1/dir2/dir3/my.file.txt
```

#### \${#var}：获得变量值的长度

```
echo ${#file}
# 输出：27
```

#### \${var:x:x}：通过索引位置截取子字符串

```
echo ${file:0:5} #截取最左侧的5个字符
# 输出：/dir1

echo ${file:5:5} #从第6个字符开始，截取5个字符
# 输出：/dir2
```

#### ${var#}、${var##}：删除字符串左侧的值

```
echo ${file#*/} #删除第一个 / 及其左侧的字符串
# 输出：dir1/dir2/dir3/my.file.txt

echo ${file##*/} #删除最后一个 / 及其左侧的字符串
# 输出：my.file.txt

echo ${file#*.} #删除第一个 . 及其左侧的字符串
# 输出：file.txt

echo ${file##*.} #删除最后一个 . 及其左侧的字符串
# 输出：txt
```

#### ${var%}、${var%%}：删除字符串右侧的值

```
echo ${file%/*} #删除最后一个 / 及其右侧的字符串
# 输出：/dir1/dir2/dir3

echo ${file%%/*} #删除第一个 / 及其右侧的字符串
# 输出：(空值)

echo ${file%.*} #删除最后一个 . 及其右侧的字符串
# 输出：/dir1/dir2/dir3/my.file

echo ${file%%.*} #删除第一个 . 及其右侧的字符串
#输出：/dir1/dir2/dir3/my
```

#### \${var:-word}：如果变量 var 为空、没有定义或已被删除（unset），那么返回 word，但不改变 var 的值。

```
echo ${var:-"var is not set"}
#输出：var is not set

echo "var is ${var}"
#此时 var 还是没有定义，所以输出：var is
```

#### \${var:=word}：如果变量 var 为空、没有定义或者已被删除，那么返回 word，并将 var 的值设置为 word。

```
echo ${var:="var is not set"}
#输出：var is not set

echo "var is ${var}"
#此时 var 已经定义为var is not set 了，所以输出：var is var is not set
```

#### \${var:?message}：如果变量 var 为空、没有定义或者已被删除，那么将消息 message 送到标准错误输出。

可以用来检测变量 var 是否可以被正常赋值。若此替换出现在 shell 脚本中，那么脚本将停止运行。

#### \${var:+word}：如果变量 var 被定义，那么返回 word，但不改变 var 的值。

### 运算符

Shell 中有很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试符。

### 算数运算符

原生 bash 不支持简单的数学运算，较为常用的是借助 `expr` 来实现数学运算。

算数运算符列表，变量 a 是 10 变量 b 是 50

| 运算符 | 说明                                      | 举例                           |
| :----- | :---------------------------------------- | :----------------------------- |
| +      | 加法                                      | `expr ${a} + ${b}` 结果为 60   |
| -      | 减法                                      | `expr ${b} - ${a}` 结果为 40   |
| \*     | 乘法                                      | `expr ${a} \* ${b}` 结果为 500 |
| /      | 除法                                      | `expr ${b} / ${a}` 结果为 5    |
| %      | 取余                                      | `expr ${b} % ${a}` 结果为 0    |
| =      | 赋值                                      | `a=$b` 就是正常的变量赋值      |
| ==     | 相等。比较两个数字，如果相等返回 true     | [ ${a} == ${b} ] 返回 false    |
| !=     | 不相等。比较两个数字，如果不相等返回 true | [ ${a} != ${b} ]返回 true      |

示例代码如下：

```
#!/bin/bash

a=10
b=50

value=`expr ${a} + ${b}`
echo "a + b = ${value}"

value=`expr ${b} - ${a}`
echo "b - a = ${value}"

value=`expr ${a} \* ${b}`
echo "a * b = ${value}"

value=`expr ${b} / ${a}`
echo "b / a = ${value}"

value=`expr ${b} % ${a}`
echo "b % a = ${value}"

if [[ ${a} == ${b} ]]
then
  echo "a 和 b 相等"
fi

if [[ ${a} != ${b} ]]
then
  echo "a 和 b 不相等"
fi

#输出
#a + b = 60
#b - a = 40
#a * b = 500
#b / a = 5
#b % a = 0
#a 和 b 不相等
```

**注意：**

1. 表达式和运算符之间要有空格，例如`1+1`是错误的，必须写成`1 + 1`
2. 完整的表达式要用反引号 ` 包住
3. 条件表达式要放在方括号之间，并且要有空格，例如 `[${a}==${b}]`是错误的，必须写成 `[ $[a] == $[b] ]`

## 扩展

### 脚本解释器在环境变量中指定

除了比较常见的用路径指定脚本解释器的方式，还有一种是指定环境变量中的脚本解释器。

```
指定脚本解释器的路径
#!/bin/bash`

指定环境变量中的脚本解释器
#!/usr/bin/env bash
```

这样做的好处是，系统会自动在 `PATH` 环境变量中查找指定的程序（如例子中的 bash）。因为程序的路径是不确定的，比如安装完新版本的 bash 后，我们有可能会把这个新的路径添加到`PATH`中，来“隐藏”老版本的 bash。所以操作系统的`PATH`变量有可能被配置为指向程序的另一个版本，如果还是直接用 `#!/bin/bash`，那么系统还是会选择老版本的 bash 来执行脚本，如果用`#!/usr/bin/env bash`，就会使用新版本了。

### $* 和 $@ 的区别

`$*` 和 `$@` 都表示传递给函数或脚本的所有参数，不被双引号（""）包含时，都是以`"$1" "$2" ... "\$n"`形式把所有参数一个一个单独输出。

但是当他们被双引号包含是，`"$*"` 会将所有的参数作为一个整体，以`"$1 $2 ... $n"`的形式输出所有参数。`"$@"` 还是跟之前一样，把所有参数分开，一个一个的输出。

```
#/bin/bash

echo "打印出没有引号的 $*"
for var in $*
do
  echo "$var"
done
#输出：打印出没有引号的 $*
#     a
#     b
#     c
#     d

echo "打印出有引号的 \"$*\""
for var in $*
do
  echo "$var"
done
#输出：打印出有引号的 "$*"
#     a b c d
```

### Shell 中的替换

#### 转义字符替换

使用 `echo` 命令时，使用 `-e` 可以对转义字符进行替换。使用 `-E` 可以禁止转义，默认也是不转义的；使用 `-n` 选项可以禁止插入换行符。

| 转义字符 | 含义                               |
| :------- | :--------------------------------- |
| \b       | 退格（删除键）                     |
| \f       | 换页（FF），将当前位置移到下页开头 |
| \n       | 换行                               |
| \r       | 回车                               |
| \t       | 水平制表符（tab 键）               |
| \v       | 垂直制表符                         |

```
#/bin/bash

a=1
b=2

echo -e "${a}\n${b}"
#输出：1
#     2
```

#### 命令替换

命令替换是指 Shell 可以先执行命令，将输出结果暂时保存，在适当的地方输出。

命令替换的语法是：反引号 ``。

```
#!/bin/bash

DATE=`date`
echo "日期是：$DATE"
#输出：日期是：Sun Oct 18 16:27:42 CST 2020
```
