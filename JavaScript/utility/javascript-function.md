<!--
 * @Author: chenfangxu
 * @Date: 2020-12-26 16:00:12
 * @Description: JavaScript 的函数
 * @LastEditors: chenfangxu
 * @LastEditTime: 2021-01-22 09:43:05
 * @FilePath: /front/JavaScript/utility/javascript-function.md
-->

# JavaScript 的函数

《JavaScript 忍者秘籍》一书中讲到：像普通人一样编写代码和像“忍者”一样编写代码的最大差别在于是否把 JavaScript 作为函数式语言来理解。对这一点的认知水平决定了你编写的代码水平。

函数及函数式概念之所以如此重要，其原因之一在于函数是程序执行过程中的主要模块单元。除了全局 JavaScript 代码是在页面构建的阶段执行的，其他的所有脚本代码都将在一个个函数内执行。

## 函数是一等公民

JavaScript 中最关键的概念是：函数是第一类对象（first-class objects），或者说函数被称为一等公民（first-class citizens）。

先看一下对象的几个特点：

- 对象可以通过字面量来创建。
- 对象可以赋值给变量、数组项，或其他对象的属性。
- 对象可以作为参数传递给函数
- 对象可以作为函数的返回值。
- 对象能够具有动态创建和分配的属性。

```
let ninja = {}; //对象通过字面量创建，赋值给变量
ninja.data = {}; //给某个对象分配一个新属性，并把这个属性赋值为一个新对象

function hide(ninja) {
  ninja.visibility = false;
}
hide({}); //一个新创建的对象作为参数传递给函数

function returnNewNinja() {
  return {}; //从函数中返回一个新对象
}
```

对比上面的对象特点来看，**当我们说函数是第一类对象的时候，就是说函数也能够实现以下功能：**

- 通过字面创建。
- 赋值给变量、数组项或其他对象的属性。
- 作为函数的参数来传递。
- 作为函数的返回值。
- 具有动态创建和分配的属性。

```
function ninjaFunction () {} //通过字面量创建
var ninjaFunction = function () {}; //为变量赋值一个新函数
ninja.data = function () {}; //给某个对象的属性赋值为一个新函数

function call (ninjaFunction) {
  ninjaFunction();
}
call(function () {}); //一个新函数作为参数传递给函数

function returnNinjaFunction() {
  return function () {}; //返回一个新函数
}

var ninjaFunction = function () {};
ninjaFunction.ninja = "Hanzo"; //为函数增加一个新属性
```

JavaScript 中函数拥有对象的所有能力，也因此函数可被作为任意其他类型对象来对待。对象能做的任何一件事，函数也能做。函数也是对象（函数实际上是对象，**每个函数都是 Function 类型的实例**，而且都与其他引用类型一样具有属性和方法。），唯一的特殊之处在于它是可调用的（invokable），即函数会被调用以便执行某项动作。

把函数作为第一类对象也是函数式编程（functional programming）的第一步。函数式编程是一种编程风格，它通过书写函数式（而不是指定一系列执行步骤，就像那种更主流的命令式编程）代码来解决问题。函数式编程可以让代码更容易测试、扩展和模块化。 _//TODO 此处可以链接到自己的函数式编程文章_

### 函数作为函数的参数来传递——回调函数

第一类对象的特点之一是：它能够作为参数传入函数。

对于函数而言，这项特性也表明：如果我们将某个函数作为参数传入另一个函数，传入的函数会在应用程序执行的未来某个时间点才执行，这个概念就是回调函数（callback function）。

回调（callback）这个术语源自于这样一个事实，即在执行过程中，我们建立的函数会被其他函数在稍后的某个时间点“再回来调用”。有效运用 JavaScript 的关键就在于回调函数。

#### 简单举例

为了透彻、完整地理解回调函数的概念，先用最简单的形式来展示一下，此例中的函数完全没有什么实际用处，但它反应了函数的一种能力，即将函数作为另一个函数的参数，随后通过参数来调用该函数。

```
function useless(ninjaCallback) {
  return ninjaCallback();
}
useless(function () {});
```

#### 复杂的例子

下面的例子中，我们会让排序算法能够获取一个比较函数作为回调，使算法在其需要比较的时候，每次都能够调用回调。sort 方法的回调函数的期望返回值为：**如果传入值的顺序需要被调换，返回正数；不需要调换，返回负数，两个值相等，返回 0.**

```
const values = [0,3,2,5,7,4,8,1]
function diff(type) {
    return function (a,b) {
        if(a > b) {
            return type === 'asc'? 1:-1;
        }else if(a < b) {
            return type === 'asc'?-1:1;
        }else {
            return 0;
        }
    }
}
console.log(values.sort(diff('desc'))) //[8, 7, 5, 4, 3, 2, 1, 0]
```

函数式方式让我们能把函数作为一个单独实体来创建，像我们对待其他类型一样，创建它、作为参数传入一个方法并将它作为一个参数来接收。函数就这样显示了它一等公民的地位。

### 函数作为对象的用法

#### 1、在集合中存储函数使我们轻易管理相关联的函数。例如：某些特定情况下必须调用的回调函数。

例如我们需要管理某个事件发生后需要调用的的回调函数集合，一般来说，管理回调函数集合时，我们并不希望存在重复函数，否则一个事件会导致同一个回调函数被多次调用。我们可以使用函数的属性，用适当的复杂度来实现它。

```
const store = {
  nextId: 1,
  cache: [],
  add: function(fn) {
    if(!fn.id) {
      fn.id = this.nextId++;
      this.cache.push(fn)
    }
  }
}

function ninja() {}
store.add(ninja)
store.add(ninja)
console.log(store.cache) // [f] 虽然添加了两次ninja，但是数组里只有一个函数
```

#### 2、记忆让函数能记住上次计算得到的值，从而提高后续调用的性能。

使用函数属性时，可以通过该函数修改函数自身，这个技巧可以用于记忆前一个计算得到的值，位置后计算节省时间。

记忆化（memoization）是一种构建函数的处理过程，能够记住上次计算结果。当函数计算得到结果时就将该结果按照参数存储起来。采用这种方式时，如果另外一个调用也使用相同的参数，我们则可以直接返回上次存储的结果而不是在计算一遍。像这样避免既重复又复杂的计算可以显著地提高性能。对于动画中的计算、搜索不经常变化的数据或任何耗时的数学计算（通过字符串生成 MD5 算法）来说，记忆化这种方式是十分有用的。

举个简单的例子，计算素数。

```
function isPrime(value) {
  if(!isPrime.answers) {
    isPrime.answers = {}; //创建缓存
  }
  if(isPrime.answers[value] !== undefined) {
    return isPrime.answers[value];
  }
  let prime = value !== 0 && value !== 1; // 1不是素数
  for(let i = 2; i < value; i++) {
    if(value % i === 0) {
      prime = false
      break;
    }
  }
  return isPrime.answers[value] = prime;
}

isPrime(5); // true
console.log(isPrime.answers) // {5: true}
```

这个方法有两个优点：

- 由于函数调用时会寻找之前调用所得到的的值，所以用户最终会乐于看到所获得的性能收益。
- 它几乎是无缝地发生在后台，最终用户和页面作者都不需要执行任何特殊请求，也不需要做任何额外的初始化，就能顺利工作。

不过也有缺点，需要权衡利弊：

- 任何类型的缓存都必然会为性能牺牲内存。
- 纯粹主义者会认为缓存逻辑不应该和业务逻辑混合，函数或方法只需要把一件事做好。
- 对于这类问题很难做负载测试或估算算法复杂度，因为结果依赖于函数之前的输入。

## 函数定义

JavaScript 函数通常由函数字面量（function literal）来创建函数值，就像数字字面量创建一个数字值一样。作为第一类对象，函数是可以用在编程语言中的值，就像字符串或数字的值。

### 函数定义方式分类

#### 1、函数定义（function declarations 或称函数声明）和函数表达式（function expression）

用 function 关键字定义的普通函数。

最常用的在定义函数上却有微妙不同的两种方式，通常不会独立地看待他们，但是意识到两者的不同能帮我们理解函数何时能够被调用。

```
function f() {} //函数声明
const f = function () {}; //函数表达式
```

#### 2、箭头函数

用 => 运算符定义的函数，是一种能让我们以尽量简洁的语法定义函数的方式。通常被叫做 lambda 函数。

```
const f = myArg => myArg * 2;
```

#### 3、函数构造函数

一种不常使用的函数定义方式，能让我们以字符串形式动态构造一个函数，这样得到的函数是动态生成的。

```
const f = new Function('a','b','return a + b')
f(1,2) // 3
```

这个例子动态地创建了一个函数，其参数为 a 和 b，返回值为两个数的和。

从技术角度讲，这是一个函数表达式。但是不推荐使用这种方式定义函数，因为这种语法会导致解析两次代码（第一次是解析常规 JavaScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。

#### 4、生成器函数

用 `function*`定义的函数。能让我们创建不同于普通函数的函数，在应用程序执行过程中，这种函数能够退出再重新进入。在这些在进入之间保留函数内变量的值。我们可以定义生成器版本的函数声明、函数表达式、函数构造函数（需要用特殊的方法先取到生成器函数的构造函数）。

```
function* g() { yield 1; }
```

#### 5、异步函数

普通函数、箭头函数和生成器函数加上 async 关键字。

```
async function f() {}
var f = async () => {}
async function* f() {}
```

#### 5、类

用 class 定义的类，实际上也是函数。

```
class F {
  constructor() {

  }
}
```

#### 6、方法

在 class 中定义的函数。

```
class F {
  f () {

  }
}
```

### 函数声明和函数表达式

#### 函数声明

强制性的 function 开头，其后紧接着强制性的函数名。

作为一个单独的 JavaScript 语句，函数声明必须独立，是独立的 JavaScript 代码块（但也能够被包含在其他函数或代码块中）。

函数声明必须有函数名是因为它们是独立语句。一个函数的基本要求是它应该能够被调用，所以它必须具有一种被引用的方式，于是唯一的方式就是通过它的名字。

扩展：由于函数是对象，因此函数名实际上是一个指向函数对象引用的指针，不会与某个函数绑定。

#### 函数表达式

作为赋值表达式的右值，或者作为其他函数的参数，这种总是其他表达式的一部分的函数叫做函数表达式。

函数表达式非常重要，在于它能准确地在我们需要使用的地方定义函数，这个过程能让代码易于理解。

对于函数表达式来说，函数名则完全是可选的。因为函数表达式是其他 JavaScript 表达式的一部分，所以我们就有了除了函数名之外调用它们的替代方法。例如一个函数表达式赋值给一个变量，就可以用这个变量调用函数。这种情况下创建的函数叫做匿名函数（anonymous function），因为 function 关键字后面没有标识符。（匿名函数有时候也叫拉姆达函数）匿名函数的 name 属性是空字符串。

#### 立即函数表达式

首先创建一个函数，然后立即调用这个新创建的函数。这种函数叫做立即调用函数表达式（IIFE），或者简写为立即函数。

```
(function () {})()
```

上面的例子中立即函数表达式的函数表达式被包裹在一对括号内，这样做的原因是纯语法层面的。JavaScript 解析器必须能够轻易区分函数声明和函数表达式之间的区别。如果去掉包裹函数表达式的括号，把立即调用作为一个独立语句 function () {}，JavaScript 开始解析时便会结束，因为这个独立语句以 function 开头，那么解析器就会认为它在处理一个函数声明。每个函数声明必须有一个名字（然而这里并没有指定名字），所以程序执行到这里会报错。为了避免错误，函数表达式要放在括号内，为 JavaScript 解析器指明它正在处理一个函数表达式而不是函数声明语句。

##### 创建立即函数表达式的其他方式

```
(function () {}())      //不常用
void function () {}();  //推荐
+function () {}();
-function () {}();
!function () {}();
~function () {}();
```

不管是加括号，还是使用一元操作符的方式区分函数表达式和函数声明，这些做法都是在向 JavaScript 引擎指明它处理的是表达式，而不是函数声明语句。

#### 函数声明和函数表达式的区别

解析器在向执行环境中加载数据时，解析器会率先读取函数声明（预解析），并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

```
sum(10,10);
var sum = function(num1, num2) {
  return num1 + num2;
}
```

上面的代码会报错，`sum is not a function`，在执行到函数所在的语句之前，变量 sum 中不会保存有对函数的引用，而且，由于第一行代码就报错，实际上也不会执行到下一行。

当然也可以同时使用函数声明和函数表达式，但实际效果跟函数表达式类似，还是会报错。

```
sum(10,10);
var sum = function sum (num1, num2) {
  return num1 + num2;
}
```

### 箭头函数

由于 JavaScript 中会使用大量函数，增加简化创建函数方式的语法十分有意义。在很多方式中，箭头函数是函数表达式的简化版。

箭头函数还能帮助我们规避一些在很多标准函数中可能遇到的难以捉摸的缺陷，比如 this 。

#### 箭头函数的定义

- 箭头函数左侧参数

箭头函数的定义以一串可选参数名列表开头，参数名以逗号分隔。如果没有参数或者多于一个参数时，参数列表就必须包裹在括号内。但如果只有一个参数时，括号就不是必须的。参数列表之后必须跟着一个胖箭头符号，以此向我们和 JavaScript 引擎指明当前处理的是箭头函数。

新操作符——胖箭头符号=>（等号后面跟着大括号）是定义箭头函数的核心。

- 箭头函数右侧函数体

如果箭头函数的函数体是一个表达式，则该箭头函数的返回值就是表达式的值。（默认带有 return 语句）

如果函数体是一个代码块，那么返回值则与普通函数一样。（如果没有 return 语句，返回值是 undefined，反之，返回值就是 return 表达式的值）

### 函数返回值

JavaScript 中无需指定函数的返回值，因为任何 JavaScript 函数都可以在任何时候返回任何值。

实际上，未指定返回值的函数返回的是一个特殊的 undefined 值。

### 严格模式对函数的一些限制

- 不能把函数名命名为 eval 或 arguments；
- 不能把参数命名为 eval 或 arguments；
- 不能出现两个命名参数同名的情况。

## 函数参数

函数参数分为实参（argument）和形参（parameter）。

- 形参是我们定义函数时所列举的变量
- 实参是我们调用函数时所传递给函数的值

当函数调用时提供了一系列实参，这些实参会以形参在函数中定义的顺序被赋值到形参上。如果实参的数量大于形参，那么额外的实参不会赋值给任何形参。反之，如果形参的数量大于实参，那么那些没有对应实参的形参则会被设为 undefined。

### 剩余参数和默认参数

#### 剩余参数

为函数的最后一个命名参数前加上三个点 ... 做前缀，这个参数就变成了一个叫作剩余参数的数组，数组内包含着传入的剩余的参数。

```
function f(a, b, ...theArgs) {}
```

注意：只有函数的最后一个参数才能是剩余参数。试图把省略号放在不是最后一个形参的任意形参之前之前都会报错。

#### 默认参数

JavaScript 创建默认参数的语法是为函数的形参赋值。

```
function performAction(ninja, action="skulking") {
  return ninja + " " + action;
}
```

可以为默认参数赋任何值，它既可以是数字或者字符串这样的基本类型，也可以是对象、数组甚至函数这样的复杂类型。每次函数调用时都会从左到右求得参数的值，并且当对后面的默认参数赋值时可以引用前面的参数。

### 隐式的函数参数

隐式的函数参数 this 和 arguments。两者会被静默地传递给函数，并且可以像函数体内显式声明的参数一样被正常访问。

参数 this 表示被调用函数的上下文对象，而 arguments 对象参数表示函数调用过程中传递的所有参数。

#### arguments 参数

arguments 参数是传递给函数的所有参数（实参）集合。无论是否有明确定义对应的形参，通过它我们都可以访问到传入函数的所有参数。

arguments 对象有一个名为 length 的属性，表示实参的确切个数。通过数组索引（数组下标）的方式可以获取单个参数的值，需要注意：这里也包括没有和函数形参相关联的其他多余的参数。

##### arguments 对象作为函数参数的别名

arguments 对象可以作为函数参数的别名，如果改变了 arguments 对象的值，同时也会影响对应的函数参数；反之亦然，如果更改了某个参数的值，会同时影响参数和 arguments 对象。

```
function f(a, b, c) {
  console.log(a,arguments[0]) // 1 1
  arguments[0] = 10
  console.log(a,arguments[0]) // 10 10
  a = 100
  console.log(a,arguments[0]) // 100 100
}

f(1,2,3)
```

如上面的代码所示，arguments[0]是参数 a 的别名，如果改变了 arguments[0]的值，参数 a 的值也会更改，如果更改了 a 的值，也会更改 arguments[0]的值。

###### 形参和实参需要对应

arguments 对象作为函数参数的别名的前提是函数的形参和实参对应的情况下，必须在最初的时候就函数的形参和 arguemnts 对应的下标位置必须都有值，否则两者就不是别名的关系。

```
function f(a, b, c) {
  console.log(c,arguments[2]) // undefined undefined
  arguments[2] = 3
  console.log(c,arguments[2]) // undefined 3
  c = 30
  console.log(c,arguments[2]) // 30 3
}

f(1,2)
```

##### arguments 参数不是数组

arguments 参数不是 JavaScript 数组，arguments 对象仅是一个类数组的结构，一定要注意避免把 arguments 参数当作数组。虽然它有 length 属性，而且可以通过数组下标的方式访问到每一个元素，但是如果尝试在 arguments 对象上使用数组的方法（例如 sort 方法），会发现最终报错。

##### 严格模式下 arguments 对象的别名无法使用

将 arguments 对象作为函数参数的别名使用时会影响代码的可读性，因此在 JavaScript 提供的严格模式（strict mode）中将无法再使用它。

##### 剩余参数（rest parameter）和 arguments 参数的区别

- 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
- arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例（也就是说能够在它上面直接使用所有的数组方法，例如 sort，map，forEach，pop 等）
- arguments 对象还有一些附加的属性（如 callee 属性）

##### arguments.callee 属性

该属性是一个指针，指向拥有这个 arguments 对象的函数。这在函数的名称是未知时很有用。

例如：定义阶乘函数，在函数有名字并且名字以后也不会变的情况下可以直接用函数名实现递归，如果函数的名字之后有变化，就可能会出现问题。

```
function factorial(num) {
  if(num <= 1) {
    return 1;
  }else {
    return num * factorial(num - 1);
  }
}
factorial(5) // 120
let trueFactorial = factorial; // 实际上是在另一个位置保存了一个函数的指针
trueFactorial(5) //120
factorial = function () {
  return 0;
}
factorial(5) // 0
trueFactorial(5) // 0
```

最后的 trueFactorial 函数还是上面的阶乘函数，只不过在走到 else 中后，调用的 factorial 函数已经不再是阶乘函数了。

```
function factorial(num) {
  if(num <= 1) {
    return 1;
  }else {
    return num * arguments.callee(num - 1);
  }
}
factorial(5) // 120
let trueFactorial = factorial;
trueFactorial(5) //120
factorial = function () {
  return 0;
}
factorial(5) // 0
trueFactorial(5) // 120
```

重写后的 factorial 函数的函数体内，没有再引用函数名，而是使用 arguments.callee，这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。

注意：严格模式下，ES5 禁止使用 arguments.callee()。当一个函数必须调用自身的时候，避免使用 arguments.callee()，通过要么给函数表达式一个名字，要么使用一个函数声明。

早期版本的 JavaScript 不允许使用命名函数表达式，所以就无法穿件一个递归函数表达式。然后就出现了通过加入 arguments.callee 解决这个问题的方案。不过这实际上是一个非常糟糕的解决方案，因为这样就不可能实现内联和尾递归，而且还会造成另外一个问题：递归调用会获取到不同的 this 值。后来，ES3 通过允许命名函数表达式解决这些问题。

#### this 参数

当调用函数时，this 参数也会默认地传递给函数。this 参数是面向对象 JavaScript 编程的一个重要组成部分，代表函数调用相关联的对象。因此，通常称之为函数上下文。

函数上下文是来自面向对象语言（如 Java）的一个概念。在这些语言中，this 通常指向定义当前方法的类的实例。

在 JavaScript 中，this 参数的指向不仅是由定义函数的方式和位置决定的，同时还严重受到函数调用方式的影响。

### 深入参数

#### 理解参数

JavaScript 函数的参数与大多数其他语言中函数的参数有所不同。JavaScript 函数不介意传递进来多少个参数，也不在乎传进来的参数是什么数据类型。原因就是 JavaScript 中的参数在内部是用一个数组表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素。无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。

#### 参数传递的都是值

JavaScript 中的所有参数传递的都是值（按值传递），不可能通过引用传递参数。

按值传递也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。

##### 变量传递的原理

在 JavaScript 中，原始类型的值存储在栈中，而对象的值存储在堆中，然后把指向堆的地址（指针）存储在栈中。原始变量以及它们的值存储在栈中，当把一个原始变量传递给另一个变量时，是把一个栈房间的东西复制到另一个栈房间，且两个原始变量互不影响。引用值是把引用变量的名字存储在栈中，但是其实际对象存储在堆中，且存在一个指针由变量名指向指向存储在堆中的实际对象。当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针，此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会随之加以改变；但如果重新赋值，此时相当于重新开了一个房间，该值的原指针改变，而另外一个值不会随它的改变而改变。

```
let value = 1;
function f(v) {
  v = 2;
  console.log(v); // 2
}
f(value) // 当传递value到f中，相当于拷贝了一份value，假设拷贝的这份值叫_value，函数中修改的都是_value，而不会影响原来的value值。
console.log(value) // 1

function setName(obj){
  obj.name = 'Tom' //参数按值传递，obj和person访问的是同一个对象，修改对象会表现在参数person上
  obj = {name: 'John'}; // obj指向一个新的地址，与person不再指向同一个地址
}
let person = new Object()
setName(person)
console.log(person.name) // Tom
```

## 函数概念扩展

### 函数重载
