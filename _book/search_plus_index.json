{"./":{"url":"./","title":"介绍","keywords":"","body":"Front-End-Basics 前端基础知识的总结，可以当笔记用的那种。 访问地址是：https://qiqihaobenben.gitbooks.io/front-end-basics/content/ 特别说明·捡贝壳 捡贝壳里面的文章都是一些个人觉得可以留存的，包括鸡汤感悟，段子笑话，经验之谈，老技术文章等等，因为有很多觉得有意思的文章，因为域名到期不续费，平台关了等各种原因看不到了，就很懊恼。 色彩斑斓的贝壳，是以后回望来时路的点点星光。 彩蛋 彩蛋就是关注奇舞周刊啊，文章写得好，想让更多人看到的同学，可以找我投稿啊。微信号：qiqihaobenben(备注:公司+名字) "},"HTML/global-attr.html":{"url":"HTML/global-attr.html","title":"HTML5全局属性汇总","keywords":"","body":"HTML5全局属性汇总 局部属性和全局属性 局部属性： 有些元素能规定自己的属性，这种属性称为局部属性。比如link元素，它具有的局部属性有href、 rel、 hreflang、 media、 type、 sizes这六个。全局属性： 可以用来配置所有元素共有的行为，这种属性称为全局属性，可以用在任何一个元素身上。 1、accesskey属性 使用accesskey属性可以设定一个或几个用来选择页面上的元素的快捷键。 HTML全局属性测试 Name: Password: Name: 在上面的例子中，三个input元素添加了accesskey属性，这样在Mac下就可以用Control + Alt(Option) + n快捷键访问到Name的输入框了。用来触发accesskey机制的按键组合因平台而异，具体如下： 浏览器/平台 Window Linux Mac Firefox Alt + Shift + key Alt + Shift + key Control + Alt + key Internet Explorer Alt + key N/A N/A Google Chrome Alt + key Alt + key Control + Alt + key Safari Alt + key N/A Control + Alt + key Opera 同Google Chrome 同Google Chrome 同Google Chrome 关于accesskey这个全局属性的详解，可以看一下HTML accesskey属性与web自定义键盘快捷访问 2、class属性 class属性用来将元素归类，这个就无需多言了。 3、contenteditable属性 contenteditable是HTML5中新增加的属性，，其用途是让用户能够修改页面上的内容。 设置为 true 是可编辑的 如上例，p元素的contenteditable属性值设置为true时，用户可以单击文字编辑内容。设置为false时禁止编辑。 4、dir属性 dir属性用来规定元素中文字的方向。有效值有两个：ltr(从左到右)、rtl(从右到左)。 从左到右 从右到左 5、draggable属性 draggable属性是HTML5支持拖放操作的方式之一，用来表示元素是否可被拖放。 6、dropzone属性 dropzone属性是HTML5支持拖放操作的方式之一，与draggable属性搭配使用。 7、id属性 id属性用来给元素分配一个唯一的标识符。这个也无需多言。需要说明的一点是，id属性还可以用来导航到文档中的特定位置。 8、hidden属性 hidden是个布尔属性，表示相关元素当前不需要关注，浏览器对它的处理方式是隐藏相关元素（隐隐想起来控制一个元素的展示隐藏的时候，会自定义一个hidden类，然后在里面写隐藏样式），具体也可以看一下这篇介绍 HTML5的hidden属性 这个元素将会被隐藏 9、lang属性 lang属性用于说明元素内容使用的语言。lang属性必须使用有效的ISO语音代码，使用这个属性的目的在于，让浏览器调整其表达元素内容的方式，比如在使用了文字朗读器的情况下正确发音。 Hello - how are you? 10、spellcheck属性 spellcheck属性用来表明浏览器是否应该对元素的内容进行拼写检查，这个属性只有用在用户可以编辑的元素上时才有意义。 spellcheck属性可以接受的值有两个：true和false。至于拼写检查的实现方式则因浏览器而异。 This is some lalalala text 11、style属性 style属性用来直接在元素身上定义CSS样式，这个也不做过多描述了。 12、tabindex属性 HTML页面的键盘焦点可以通过按Tab键在各元素之间切换。用tabindex属性可以改变默认的转移顺序。 Name: City: Country: 上面的代码实现效果是：在按Tab键的过程中，tabindex为1的Country输入框第一个被选中，接着焦点会跳到Name输入框，最后是submit提交。tabindex设置为-1的元素不会在用户按下Tab键后被选中。 13、title属性 title属性提供了元素的额外信息，浏览器通常用这些东西显示工具条提示，这个在一些展示不全的文本标题也经常使用。 qiqihaobenben.github.io "},"CSS/layouts/flexbox.html":{"url":"CSS/layouts/flexbox.html","title":"flexbox 布局","keywords":"","body":"CSS弹性盒子布局 简介 CSS弹性盒子布局定义了一种针对用户界面设计而优化的CSS盒子模型。 在弹性布局模型中，弹性容器的子元素可以在任何方向上排布，也可以“弹性伸缩”其尺寸，既可以增加尺寸以填满未使用的空间，也可以收缩尺寸以避免从父元素溢出。子元素的水平对齐和垂直对齐都能很方便的进行操控。 在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，这是默认的设置，但是可以更改，所以不能一概认为宽度就是主轴，垂直就是侧轴，需要根据 flex-direction 来判断。在 flex 容器中的每个子元素被称为 flex item 占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。如下图： flex容器 实现flex布局首先指定一个容器。 .container { display: flex; //块级盒子 } .container { display: inline-flex; //行内盒子 } 注意： 容器设置flex布局后，子元素的 float 、clear 、vertical-align 属性将会失效。 设置在容器上的属性 flex-direction flex-wrap flex-flow justify-content align-items align-content 1、flex-direction: 决定主轴的方向（即项目的排列方向） .container { flex-direction: row | row-reverse | column | column-reverse; } 属性值 描述 row(默认) 指定主轴水平, 子项目从左至右排列➜ row-reverse 指定主轴水平，子项目从右向左排列⬅︎ column 指定主轴垂直，子项目从上至下排列⬇︎ column-reverse 指定主轴垂直，子项目从下往上排列⬆︎ 2、flex-wrap：决定容器内子元素是否可换行 .container { flex-wrap: no-wrap | wrap | wrap-reverse; } 属性值 描述 no-wrap(默认值) 默认不换行,即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整(缩小)而并不会挤到下一行。 wrap 正常换行 wrap-reverse 换行，第一行在下方 3、flex-flow: flex-direction 和 flex-wrap 的简写形式 .container { flex-flow: || ; } 默认值为: row nowrap 4、justify-content: 定义了子元素在主轴上的对齐方式 .container { justify-content: flex-start | flex-end | center | space-between | space-around; } 属性值 描述 flex-start 子项目起始位置与main start位置对齐 flex-end 子项目末尾位置与main end位置对齐 center 在主轴方向居中于容器 space-between 两端对齐，项目之间的间隔相等，即剩余空间等分成间隙 space-around 每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍 5、align-items: 定义了子元素在交叉轴上的对齐方式 .container { align-items: flex-start | flex-end | center | baseline | stretch; } 属性值 描述 flex-start 子项目起始位置与cross start位置对齐 flex-end 子项目末尾位置与cross end位置对齐 center 在交叉轴方向居中于容器 baseline 第一行文字的基线对齐 stretch(默认) 高度未定(或auto)时, 将占满容器的高度 6、align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用 .container { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 当你 flex-wrap 设置为 nowrap 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。 当你 flex-wrap 设置为 wrap 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。 属性值 描述 flex-start 顶部与cross start位置对齐 flex-end 底部与cross end位置对齐 center 在交叉轴方向居中于容器 space-between 与交叉轴两端对齐, 间隔全部相等 space-around 每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。 stretch 多根主轴上的子项目充满交叉轴 设置在flex item上的属性 order flex-basis flex-grow flex-shrink flex align-self 1、order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0 .item { order: ; } 2、flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间 .item { flex-basis: | auto; } 默认值：auto，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。 当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。 当 flex-basis 值为 auto 时，则根据尺寸的设定值(假如为 100px)，则这 100px 就为项目的大小。 3、flex-grow: 定义项目的放大比例 .item { flex-grow: ; } 默认值为 0，即如果存在剩余空间，也不放大。 当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话) 如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要flex-shrink 这个属性。 grow 在 flex 容器下的子元素的宽度和比容器和小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。 4、flex-shrink: 定义了项目的缩小比例 .item { flex-shrink: ; } 默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。 如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。 5、flex: flex-grow,flex-shrink和flex-basis的简写 .item{ flex: none | [ ? || ] } flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。 有关快捷值：auto (1 1 auto) 和 none (0 0 auto) 关于 flex 取值，还有许多特殊的情况，可以按以下来进行划分： (1) 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的： .item {flex: 1;} .item { flex-grow: 1; flex-shrink: 1; flex-basis: 0%; } (2) 当 flex 取值为 0 时，对应的三个值分别为 0 1 0% .item { flex: 0; } .item { flex-grow: 0; flex-shrink: 1; flex-basis: 0%; } (3) 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字） .item-1 {flex: 0%;} .item-1 { flex-grow: 1; flex-shrink: 1; flex-basis: 0%; } .item-2 {flex: 24px;} .item-2 { flex-grow: 1; flex-shrink: 1; flex-basis: 24px; } (4) 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的： .item {flex: 2 3;} .item { flex-grow: 2; flex-shrink: 3; flex-basis: 0%; } (5) 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的： .item {flex: 11 32px;} .item { flex-grow: 11; flex-shrink: 1; flex-basis: 32px; } flex-shrink 和 flex-grow 只有一个能起作用，这其中的道理细想起来也很浅显：空间足够时，flex-grow 就有发挥的余地，而空间不足时，flex-shrink 就能起作用。当然，flex-wrap 的值为 wrap / wrap-reverse 时，表明可以换行，既然可以换行，一般情况下空间就总是足够的，flex-shrink 当然就不会起作用 6、align-self:允许单个项目有与其他项目不一样的对齐方式 单个项目覆盖 align-items 定义的属性 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 这个跟 align-items 属性时一样的，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。 推荐链接 30 分钟学会 Flex 布局 Flex 布局教程：语法篇 Flex 布局示例 Flexbox彻底研究——PPT FLEXBOX FROGGY——一款边学边玩的小游戏 "},"CSS/layouts/middle.html":{"url":"CSS/layouts/middle.html","title":"居中布局","keywords":"","body":"水平垂直居中布局 demo:水平垂直居中的展示页面 子元素定宽高 1、absolute + margin负值 .container { position: relative; margin: 0 auto; width: 600px; height: 400px; border: 2px solid #666; } .item { position: absolute; left: 50%; top: 50%; margin-left: -100px; margin-top: -100px; width: 200px; height: 200px; background-color: #8c7676; } 2、absolute(left,right,top,bottom) + margin + width + height .container { position: relative; margin: 0 auto; width: 600px; height: 400px; border: 2px solid #666; } .item { position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; width: 200px; height: 200px; background-color: #8c7676; } 兼容性：主流浏览器均支持。 注意：子元素必须为固定宽高 子元素不定宽高 1、display:table-cell; .container { display: table-cell; text-align: center; vertical-align: middle; margin: 0 auto;/*margin在table-cell下已经不起用了*/ width: 600px; height: 400px; border: 2px solid #666; } .item { display: inline-block; padding: 100px; /*用padding来撑开元素，没有设置宽高*/ background-color: #8c7676; } 兼容性：由于display:table-cell的原因，IE6\\7不兼容。 注意：无论父元素还是子元素都不能浮动，如果父元素浮动，元素就只能水平居中，如果子元素浮动，则子元素按照浮动的方向走。 2、absolute + transform .container { position: relative; margin: 0 auto; width: 600px; height: 400px; border: 2px solid #666; } .item { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); padding: 100px;/*用padding来撑开元素，没有设置宽高*/ background-color: #8c7676; } 兼容性：浏览器必须支持transform。 3、display: flex; .container { display: flex; justify-content: center; align-items: center; margin: 0 auto; width: 600px; height: 400px; border: 2px solid #666; } .item { display: inline-block; padding: 100px;/*用padding来撑开元素，没有设置宽高*/ background-color: #8c7676; } 兼容性：浏览器必须支持flex。 4、text-align:center;vertical-align:middle; .container { text-align: center; font-size: 0; margin: 0 auto; width: 600px; height: 400px; border: 2px solid #666; } .container::before { display: inline-block; content: ''; width: 0; height: 100%; vertical-align: middle; } .item { display: inline-block; vertical-align: middle; padding: 100px;/*用padding撑开元素，没有设置宽高*/ font-size: 12px;/*重新设置子元素内的字体大小*/ background-color: #8c7676; } 兼容性：主流浏览器均支持。 注意：子元素必须要是inline-block或者inline的元素，并且子元素不能绝对定位和浮动。 5、calc .container { position: relative; margin: 0 auto; width: 600px; height: 400px; border: 2px solid #666; } .item { position: absolute; left: calc(50% - 200px / 2); top: calc(50% - 200px / 2); width: 200px; height: 200px; background-color: #8c7676; } 兼容性：浏览器必须支持calc。 推荐资源 CSS元素水平垂直居中方法总结里面还有关于背景图的居中和兼容低版本浏览器的写法 "},"JavaScript/utility/data-interaction/ajax.html":{"url":"JavaScript/utility/data-interaction/ajax.html","title":"Ajax通俗讲解","keywords":"","body":"Ajax Asynchronous JavaScript and XML : 异步的js和XML，前后端数据交互的一种技术。 Ajax优点 传输获取数据 , 不用跳转页面，在本页面请求服务器，做到实时验证。减少用户返工率并且优化用户体验。 方式 GET方式 把数据放在url中发送，以获取数据为主 步骤 1、创建一个ajax对象 var ajax = new XMLHttpRequest(); 2、传入请求参数 //method,url,true 参数 ajax.open('get','php/get.php?user='+encodeURIComponent(value),true); 3、发送数据 ajax.send(null); send()方法传入一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入null，因为这个参数对有些浏览器来说是必需的。 注意点 1、用get方式请求，是有长度限制的。因为是通过地址栏的查询信息来请求的。（即get通过url地址传输，post通过浏览器内部传输） 2、请求信息在地址栏中显示，直接暴露了用户填写的信息，并且访问的数据会被浏览器缓存到历史记录中，所以说不安全。 3、在get拼接数据的时候要用encodeURIComponent来包一下，不然在IE低版本浏览器中使用中文会乱码的。 encodeURIComponent('刘') 转成url decodeURIComponent('%E5%88%98') 转成中文 4、有缓存问题 解决方法：在url？后面连接一个随机数，时间戳 POST方式 数据放在 send() 中发送 步骤 1、创建一个ajax对象 var ajax = new XMLHttpRequest(); 2、传入请求参数 ajax.open('post','php/post.php',true); //method,url,true三个参数的含义 1、提交方式 Form-method 2、提交地址 Form-action 3、异步（同步） 异步:非阻塞 前面的代码不会影响后面代码的执行 同步:阻塞 前面的代码会影响后面代码的执行 3、设置请求头 ajax.setRequestHeader('Content-Type','application/x-www-form-urlencoded') // 要成功的发送请求头部信息，必须在调用open() 方法之后且调用send()方法之前调用setRequestHeader() 4、发送数据 ajax.send('user=cfangxu') 注意点 用post方式请求，理论上来说是没有长度或体积限制的，看具体浏览器和后端的设置。 数据是通过http正文（请求体-请求正文）进行发送的，不会直接的暴露用户的信息，并且发送的数据不会被浏览器缓存，相对来说是比较安全的。 在send()的前面需要设置一个请求头（不设置要出错）。 post提交的数据格式有多种 text/plain application/x-www-form-urlencoded - 默认 multipart/form-data 在post提交数据的时候，需要设置请求头content-type:值可以为上面三中类型之一 ajax.setRequestHeader( 'Content-Type','application/x-www-form-urlencoded'); open的时候，不用像get那样去拼数据，拼接数据是在send中填写。 接收数据 onload 事件 属于html5的，有兼容性问题 ajax.onload = function () { //打印传输过来的数据 console.log(ajax.responseText) } onreadystatechange 事件 支持IE6，兼容性好。 其中的readyState属性：请求状态 0 （未初始化）还没有调用open()方法0是监听不到的 1 启动，open() 方法已经被调用。 2 发送，send() 方法已经被调用，但尚未接收到响应。 3 接收，已经接收到部分相应数据。 4 完成，已经接收到全部响应数据，而且可以在客户端使用了。 readyState : ajax工作状态onreadystatechange : 当readyState改变的时候触发status : 服务器状态，http状态码responseText : 返回以文本形式存放的内容 ajax请求返回的内容就被存放到这个属性下面 注意 事件监听最好写在事件发生之前(即.onload（.onreadystatechange）要放在.send之前)，避免没有监听到。 扩展 XMLHttpRequest 兼容性问题，单纯了解，可以直接略过 new XMLHttpRequest() ie6 及以下不支持，所以需要用到插件 new ActiveXObject('MSXML2.XMLHTTP') IE中会有三种不同的XHR版本： MSXML2.XMLHTTP 、 MSXML2.XMLHTTP.3.0 、 MSXML2.XMLHTTP.6.0 因为只做了解，这里用最老的那一版 兼容写法如下： var xhr = null; if (window.XMLHttpRequest) { //直接用XMLHttpRequest是不能做判断的，因为IE6下没有，window.XMLHttpRequest会返回undefined xhr = new XMLHttpRequest(); } else { xhr = new ActiveXObject('MSXML2.XMLHTTP'); } 也可以用try catch来解决。 try { xhr = new XMLHttpRequest(); } catch (e) { xhr = new ActiveXObject('MSXML2.XMLHTTP'); } 表单提交 form 标签的一些属性 action : 数据提交的地址，默认是当前页面 method : 数据提交的方式，默认是get方式 1.get 把数据名称和数据值用=连接，如果有多个的话，那么他会把多个数据组合用&进行连接，然后把数据放到url?后面传到指定页面 2.post 通过请求头进行请求 enctype : 提交的数据格式，默认application/x-www-form-urlencoded 上传文件 不管是form还是ajax,上传必须要用post请求方式来传输。如果后端返回的内容有中文编码格式，那么直接输入到页面中就能变成中文了。 form action会跳转页面 ajax var ajax = new XMLHttpRequest(); ajax.open('post','post_file.php',true); //传输类型设置为二进制的格式 ajax.setRequestHeader('Content-Type','multipart/form-data'); //二进制传输在写入send前要用FormData转换 var fromD = new FormData(); //FormData构造函数中有一个append方法 //在file中，有一个对象：files（详细信息的列表）files[0]里面是files的具体参数； fromD.append('file',f.files[0]); ajax.send(fromD) ajax的上传方式需要注意以下几点： 1.new FormData() 2.给这个对象append(key,value) key：跟后端的要求走 value:file元素的files[0]; 3.send(这个对象) XMLHttpRequest 2级 FormData 上面的ajax上传文件用到的 FormData 类型就是 XMLHttpRequest 2级中定义的。\b FormData 为序列化表单以及创建与表单格式相同的数据(用于XHR传输)提供了便利。 var data = new FormData(); data.append('name','cfangxu'); append()方法接收两个参数：键和值，分别对应表单字段的名字和字段中包含的值。可以像上面代码一样添加任意多个值。 FormData 构造函数可以直接传入表单元素，表单元素的数据预先向其中填入键值对。 var data = new FormData(document.forms[0]); FormData的另一个方便之处在于用其发送POST请求可以不必明确地在XHR对象上设置请求头部，XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。 overrideMimeType() 方法 重写XHR响应的MIME类型，比如服务器返回的MIME类型是 text/plain，但是数据中实际包含的是XML。根据MIME类型，即使数据是XML， responseXML属性中仍然是null，通过调用 overrideMimeType()方法，可以保证把响应当做XML而并非文本来处理。 var xhr = new XMLHttpRequest(); xhr.open('get','text.php',true); xhr.overrideMimeType('text/xml'); xhr.send(null); load 事件 上面提到过，用load事件替代readystatechange,响应接收完毕后会触发load事件，所以也就没有必要去检查readyState属性了，不过只要浏览器接收到服务器的响应，不管状态如何，都会触发load事件。所以必须要检查status属性，才能确定数据是否真的是可用的。 var xhr = new XMLHttpRequest(); xhr.onload = function () { if(xhr.status >= 200 && xhr.status progress 事件 这个事件会在浏览器接收新数据期间周期性地触发。事件监听函数会接收到一个event对象，其target属性是XHR对象，但是包含着三个额外的属性：lengthComputable、position和totalSize。 lengthComputable: 是一个表示进度信息是否可用的布尔值。 position: 表示已经接收的字节数 totalSize: 表示根据Content-Length响应头部确定的预期字节数。 这些信息可以用来展示进度。 var xhr = new XMLHttpRequest(); xhr.onload = function () { if(xhr.status >= 200 && xhr.status 为确保正常执行，必须在调用open()方法之前添加onprogress事件监听函数。 总结 XMLHttpRequest实例的属性 readyStateresponseTyperesponseTextresponseXMLstatusstatusTextwithCredentials XMLHttpRequest实例的方法 abort() abort方法用来终止已经发出的HTTP请求。getAllResponseHeaders()getResponseHeader()open()send()setRequestHeader()overrideMimeType() XMLHttpRequest实例的事件 readyStateChange事件progress事件load事件 "},"JavaScript/utility/data-interaction/cross-origin.html":{"url":"JavaScript/utility/data-interaction/cross-origin.html","title":"前端请求跨域","keywords":"","body":"前端请求跨域 一些定义 同源： 相同来源 同域名、同端口、同协议 同源策略： 是一种约定，最核心也最基本的安全功能，Web是构建在同源策略基础之上的。 跨域： 访问/请求某个接口/某个地址：必须遵循同域名、同端口、同协议才能正常使用。只要有一个不统一，那么就为跨域。如果不同源，就会产生跨域问题。 如果非同源，共有三种行为受到限制。 Cookie、LocalStorage 和 indexedDB 无法读取。 DOM 无法获得。 AJAX 请求不能发送。 Ajax跨域解决 JSONP JSONP是之前服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 基本思想 网页通过添加一个元素，向服务器请求JSON数据，这种做法不受同源政策限制(因为script、img这些带src请求资源的都能请求网络的任意位置资源)；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 具体方法 1、首先，网页动态插入元素，由它向跨源网址发出请求。 function addScriptTag(src) { var script = document.createElement('script'); script.setAttribute(\"type\",\"text/javascript\"); script.src = src; document.body.appendChild(script); } window.onload = function () { addScriptTag('http://example.com/ip?callback=foo'); } function foo(data) { console.log('Your public IP address is: ' + data.ip); }; 上面代码通过动态添加元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。 2、服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 foo({ \"ip\": \"8.8.8.8\" }); 由于元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 图解流程： 基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。 CORS CORS是一个W3C标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 简介 CORS需要浏览器和服务器同时支持。 目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 两种请求 浏览器将CORS请求分成两类：简单请求（simple request） 和 非简单请求（not-so-simple request）。 简单请求 只要同时满足以下两大条件，就属于简单请求。 (1) 请求方法是以下三种方法之一： HEAD GET POST (2)HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 处理简单请求基本流程 对于简单请求，浏览器直接发出CORS请求。具体来说，浏览器如果发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 (1)Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 (2)Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 (3)Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。 扩展——withCredentials CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性。否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。如下： //服务器端设置 Access-Control-Allow-Credentials: true //客户端设置 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 注意：1、如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 xhr.withCredentials = false; 2、如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。即不同时满足简单请求两个条件的就是非简单请求。 预检请求 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。如下： var url = 'http://api.alice.com/cors'; var xhr = new XMLHttpRequest(); xhr.open('PUT', url, true); xhr.setRequestHeader('X-Custom-Header', 'value'); xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个\"预检\"请求，要求服务器确认可以这样请求。下面是这个\"预检\"请求的HTTP头信息。 OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... \"预检\"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，\"预检\"请求的头信息包括两个特殊字段。 (1)Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 (2)Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求回应 服务器收到\"预检\"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 预检请求失败 浏览器否定了\"预检\"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 XMLHttpRequest cannot load http://api.alice.com. Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下: Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 (1)Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求。 (2)Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段。 (3)Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 (4)Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 预检请求成功 一旦服务器通过了\"预检\"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是\"预检\"请求之后，浏览器的正常CORS请求： PUT /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com X-Custom-Header: value Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应: Access-Control-Allow-Origin: http://api.bob.com Content-Type: text/html; charset=utf-8 与JSONP比较 CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 "},"JavaScript/utility/fe-algorithm/array.html":{"url":"JavaScript/utility/fe-algorithm/array.html","title":"数组的十八般武艺","keywords":"","body":"数组 数组是值的有序集合，每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。 JavaScript数组的索引是基于零的32位数值，第一个元素索引为0，数组最大能容纳4294967295（即2^32-1）个元素。 JavaScript数组是动态的，根据需要它们会增长或缩减，并且在创建数组时无需声明一个固定的大小或者在数组大小变化时无需重新分配空间。 JavaScript数组可能是稀疏的，数组元素的索引不一定要连续的，它们之间可以有空缺。 每个JavaScript数组都有一个length属性，针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length比所有元素的索引都要大。 创建数组 1、最简单的方法是使用数组直接量(字面量)创建数组。 var empty = []; //没有元素的数组 var arr = [1.1, true, \"a\",]; //3个不同类型的元素和结尾的逗号 数组直接量中的值也不一定必须是常量，它们可以是任意的表达式： var number = 1; var list = [number, number+1, number+2]; 如果省略数组直接量中的某个值，省略的元素用empty表示（就是没有这个元素），访问的话会返回undefined。 var count = [1,,3]; // 数组打印出来是(3) [1, empty, 3], count[1] === undefined是true。 var undefs = [,,]; // 数组直接量语法允许有可选的结尾的逗号，顾[,,]只有两个元素而非三个，undefs.length 是 2 2、构造函数Array()创建数组 调用时没有参数，等同于[]，创建一个没有任何元素的空数组 var arr = new Array(); 调用时有一个数值参数，它指定长度 var arr = new Array(10) // (10) [empty × 10] 显式指定两个或者多个数组元素或者数组元素的一个非数值元素 var arr = new Array(1,2,3,\"one\"); 3、ES6的一些方法 （1）Array.of() 返回由所有参数组成的数组，不考虑参数的数量或类型，如果没有参数就返回一个空数组 (ES6新增) 参数： elementN 任意个参数，将按顺序成为返回数组中的元素。 注意： of() 可以解决上述构造器因参数个数不同，导致的行为有差异的问题(参数只有一个数值时，构造函数会把它当成数组的长度)。 Array.of(1,2,3); // [1,2,3] Array.of(1,{a:1},null,undefined) // [1, {a:1}, null, undefined] // 只有一个数值参数时 let B = new Array(3); // (3) [empty × 3] let C = Array.of(3); // [3] 返回值： 新的 Array 实例。 （2）Array.from()从一个类数组或可迭代对象中创建一个新的数组 (ES6新增) 参数： 第一个参数：想要转换成数组的类数组或可迭代对象 第二个参数（可选）：回调函数，类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。 第三个参数（可选）：绑定回调函数的this对象 // 有length属性的类数组 Array.from({length：5},(v,i) => i) //[0, 1, 2, 3, 4] // 部署了Iterator接口的数据结构 比如:字符串、Set、NodeList对象 Array.from('hello') // ['h','e','l','l','o'] Array.from(new Set(['a','b'])) // ['a','b'] // 传入一个数组生成的是一个新的数组，引用不同，修改新数组不会改变原数组 let arr1 = [1,2,3] let arr2 = Array.from(arr1); arr2[1] = 4; console.log(arr1,arr2) //[1, 2, 3] [1, 4, 3] 返回值： 新的 Array 实例。 知识点 //数组合并去重 function combine(){ let arr = [].concat.apply([], arguments); //没有去重复的新数组，之后用Set数据结构的特性来去重 return Array.from(new Set(arr)); } var m = [1, 2, 2], n = [2,3,3]; console.log(combine(m,n)); 数组方法 1、会改变原数组的方法 1. push() 方法在数组的尾部添加一个或多个元素，并返回数组的长度 参数: item1, item2, ..., itemX ,要添加到数组末尾的元素 let arr = [1,2,3]; let length = arr.push('末尾1','末尾2'); // 返回数组长度 console.log(arr,length) // [1, 2, 3, \"末尾1\", \"末尾2\"] 5 返回值： 数组的长度 2. pop() 方法删除数组的最后一个元素，减小数组长度并返回它删除的值。 参数：无 //组合使用push()和pop()能够用JavaScript数组实现先进后出的栈 let stack = []; stack.push(1,2) // 返回长度2，这时stack的值是[1,2] stack.pop() // 返回删除的值2，这时stack的值是[1] 返回值： 从数组中删除的元素(当数组为空时返回undefined)。 3. unshift() 方法在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。 参数: item1, item2, ..., itemX ,要添加到数组开头的元素 let arr = [3,4,5]; let length = arr.unshift(1,2); // 返回长度是5 console.log(arr, length) //[1, 2, 3, 4, 5] 5 注意： 当调用unshift()添加多个参数时，参数时一次性插入的，而非一次一个地插入。就像是上例添加1和2，他们插入到数组中的顺序跟参数列表中的顺序一致，而不是[2,1,3,4,5]。 返回值： 返回数组新的长度。 4. shift() 方法删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺，返回值是删除的元素 参数: 无。 let arr = [1,2,3]; let item = arr.shift(); // 返回删除的值1 console.log(arr, item) // [2, 3] 1 返回值： 从数组中删除的元素; 如果数组为空则返回undefined 。 5. splice() 方法是在数组中插入或删除元素的通用方法 语法 array.splice(start[, deleteCount[, item1[, item2[, ...]]]]) 参数： start​ 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数）；若只使用start参数而不使用deleteCount、item，如：array.splice(start) ，表示删除[start，end]的元素。 deleteCount (可选) 整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。 如果deleteCount被省略，则其相当于(arr.length - start)。 item1, item2, ... (可选) 要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。 返回值： 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。 // start不超过数组长度(以下操作是连续的) let arr = [1,2,3,4,5]; arr.splice(2) // arr是[1,2]，返回值是[3,4,5] arr.splice(1,1) // arr是[1]，返回值是[2] arr.splice(0,3) // arr是[]，返回值是[1],因为此时数组从第0位开始不够3位，所以是删除从0开始到最后的所有元素。 // start大于数组长度(以下操作是连续的) let arr = [1,2,3,4,5]; arr.splice(5) // arr是[1,2,3,4,5]，返回值是[] arr.splice(5,3,6) // arr是[1,2,3,4,5,6]，返回值是[] arr.splice(5,3,7) // arr是[1,2,3,4,5,7] 返回值是[6] // start是负数(以下操作是连续的) let arr = [1,2,3,4,5]; arr.splice(-3,2); // arr是[1,2,5], 返回值是[3,4] arr.splice(-4); // arr是[],返回值是[1,2,5] // 插入数组时，是插入数组本身，而不是数组元素 let arr = [1,4,5]; arr.splice(1,0,[2,3]) // arr是[1,[2,3],4,5]，返回值是[] 6. sort() 方法将数组中的元素排序并返回排序后的数组 参数： compareFunction (可选) 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 var stringArray = [\"Blue\", \"Humpback\", \"Beluga\"]; var numberArray = [40, 1, 5, 200]; function compareNumbers(a, b){ return a - b; } console.log('stringArray:' + stringArray.join()); console.log('Sorted:' + stringArray.sort()); console.log('numberArray:' + numberArray.join()); // 没有使用比较函数时，数字并不会按照我们设想的那样排序 console.log('Sorted without a compare function:'+ numberArray.sort()); console.log('Sorted with compareNumbers:'+ numberArray.sort(compareNumbers)); //打印如下 // stringArray: Blue,Humpback,Beluga // Sorted: Beluga,Blue,Humpback // numberArray: 40,1,5,200 // Sorted without a compare function: 1,200,40,5 // Sorted with compareNumbers: 1,5,40,200 返回值： 返回排序后的数组。原数组已经被排序后的数组代替。 7. reverse() 方法将数组中的元素颠倒顺序，返回逆序的数组。 参数: 无 let arr = [1,2,3]; arr.reverse() // arr是[3,2,1]，返回值是[3,2,1] 返回值： 返回顺序颠倒后的数组。原数组已经被排序后的数组代替。 8. copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。 (ES6新增) 语法： arr.copyWithin(target[, start[, end]]) 参数： target 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。 如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。 start 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。 如果 start 被忽略，copyWithin 将会从0开始复制。 end 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。 如果 end 被忽略，copyWithin 将会复制到 arr.length。 返回值： 改变了的数组。 [1, 2, 3, 4, 5].copyWithin(-2); // [1, 2, 3, 1, 2] [1, 2, 3, 4, 5].copyWithin(0, 3); // [4, 5, 3, 4, 5] [1, 2, 3, 4, 5].copyWithin(0, 3, 4); // [4, 2, 3, 4, 5] [1, 2, 3, 4, 5].copyWithin(-2, -3, -1); // [1, 2, 3, 3, 4] // copyWithin 函数是设计为通用的，其不要求其 this 值必须是一个数组对象。 [].copyWithin.call({length: 5, 3: 1}, 0, 3); // {0: 1, 3: 1, length: 5} 9. fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。 (ES6新增) 语法: arr.fill(value[, start[, end]]) 参数： value 用来填充数组元素的值。 start (可选) 起始索引，默认值为0。 end (可选) 终止索引，默认值为 this.length。 如果 start 是个负数, 则开始索引会被自动计算成为 length+start, 其中 length 是 this 对象的 length 属性值. 如果 end 是个负数, 则结束索引会被自动计算成为 length+end。 返回值： 修改后的数组 [1, 2, 3].fill(4); // [4, 4, 4] [1, 2, 3].fill(4, 1); // [1, 4, 4] [1, 2, 3].fill(4, 1, 2); // [1, 4, 3] [1, 2, 3].fill(4, 1, 1); // [1, 2, 3] [1, 2, 3].fill(4, 3, 3); // [1, 2, 3] [1, 2, 3].fill(4, -3, -2); // [4, 2, 3] [1, 2, 3].fill(4, NaN, NaN); // [1, 2, 3] [1, 2, 3].fill(4, 3, 5); // [1, 2, 3] Array(3).fill(4); // [4, 4, 4] //fill 方法故意被设计成通用方法, 该方法不要求 this 是数组对象。 [].fill.call({ length: 3 }, 4); // {0: 4, 1: 4, 2: 4, length: 3} 2、不改变原数组的方法 1. slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。且原始数组不会被修改。 参数： begin (可选) 从该索引处开始提取原数组中的元素（从0开始）。 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。 如果省略 begin，则 slice 从索引 0 开始。 end (可选) 在该索引处结束提取原数组元素（从0开始）。 slice会提取原数组中索引从 begin 到 end 的所有元素（包含begin，但不包含end）。 slice(1,4) 提取原数组中的第二个元素开始直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。 如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1)表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 如果 end 被省略，则slice 会一直提取到原数组末尾。 如果 end 大于数组长度，slice 也会一直提取到原数组末尾。 返回值： 一个含有提取元素的新数组 let arr = [1,2,3,4,5]; let arr1 = arr.slice(1,3); // arr是[1,2,3,4,5]， arr1是[2,3] let arr2 = arr.slice(-2,-1); // arr是[1,2,3,4,5], arr2是[4] // 开始位置在结束位置后面，得到的数组是空 let arr3 = arr.slice(-2, -3); // arr是[1,2,3,4,5], arr3是[] let arr4 = arr.slice(2, 1); // arr是[1,2,3,4,5], arr4是[] //如果元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 let arr = [{name: 'xiaoming'}]; let arr1 = arr.slice(); // arr是[{name: xiaoming}]，arr1是[{name: 'xiaoming'}] arr1[0].name = 'xiaogang'; // arr是[{name: 'xiaogang'}]，arr1是[{name: 'xiaogang'}] // 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 let arr = [1,2,3]; let arr1 = arr.slice(); // arr是[1,2,3]，arr1是[1,2,3] arr1[1] = \"two\"; // arr是[1,2,3]，arr1是[1,\"two\",3] // 当然，如果向两个数组任一中添加了新元素（简单或者引用类型），则另一个不会受到影响。 2. join() 方法将数组（或一个类数组对象）中所有元素都转化为字符串并连接在一起，返回最后生成的字符串。 参数： separator （可选） 指定一个字符串来分隔数组的每个元素。 如果有(separator)，将分隔符转换为字符串。 如果省略()，数组元素用逗号分隔。默认为 \",\"。 如果separator是空字符串(\"\")，则所有元素之间都没有任何字符。 let num = [1,2,3]; let str1 = num.join(); // 1,2,3 let str2 = num.join(', ') // 1, 2, 3 let str3 = num.join('') // 123 //所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined 或者null， 则会转化成空字符串。 let num = [1,null,3]; let str1 = num.join(); // 1,,3 //如果数组中的元素是数组，会将里面的数组也调用join() let num = [[1,2],3]; let str1 = num.join('-'); // 1,2-3 // 如果数组中的元素是对象，对象会被转为[object Object]字符串 let num = [{num: 1},2,3]; let str1 = num.join('-'); // [object Object]-2-3 返回值： 一个所有数组元素连接的字符串。如果 arr.length 为0，则返回空字符串 知识点 // 扁平化简单的二维数组 const arr = [11, [22, 33], [44, 55], 66]; const flatArr = arr.join().split(','); // [\"11\", \"22\", \"33\", \"44\", \"55\", \"66\"] 3. toString() 方法将数组的每个元素转化为字符串(如有必要将调用元素的toString()方法)并且输出用逗号分割的字符串列表。返回一个字符串表示数组中的元素 参数： 无 [1,2,3].toString(); // 1,2,3 [1,[2,'c']].toString(); //1,2,c // 以上与不使用任何参数调用join()方法返回的字符串是一样的。 // 以下的这个例子要跟下面的toLocaleString对照看 [{a:1},1,new Date()].toString() //\"[object Object],1,Sat Jul 07 2018 18:43:45 GMT+0800 (中国标准时间)\" 注意： 当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串 [1,2,3]+'abc' //1,2,3abc 返回值： 返回一个字符串表示数组中的元素 知识点 // 扁平化简单的二维数组 const arr = [11, [22, 33], [44, 55], 66]; const flatArr = arr.toString().split(','); // [\"11\", \"22\", \"33\", \"44\", \"55\", \"66\"] 4. toLocaleString() 数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 \",\"）隔开。 参数：(还有待考证,我试了一下没用，看了一下ECMA的官网，确实是标注有两个可选参数的) locales （可选） 带有BCP 47语言标记的字符串或字符串数组 options （可选） 一个可配置属性的对象 //数组中的元素将会使用各自的 toLocaleString 方法： // Object: Object.prototype.toLocaleString() // Number: Number.prototype.toLocaleString() // Date: Date.prototype.toLocaleString() let prices = ['￥7', 500, 8123, 12]; // 不带参数 prices.toLocaleString(); // \"￥7,500,8,123,12\" //带参数 prices.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' }); // \"￥7,500,8,123,12\" //MDN上的举例中说是 \"￥7,￥500,￥8,123,￥12\"，在浏览器和Node中验证了返回的都是 \"￥7,500,8,123,12\" 啊！ // 以下的这个例子要跟上面的toString对照看 [{a:1},1,new Date()].toLocaleString() //\"[object Object],1,2018/7/7 下午6:45:00\" 返回值： 表示数组元素的字符串。 5. concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 它的元素包括调用concat()的原始数组的元素和concat()的每个参数，但是要注意，concat()不会递归扁平化数组的数组，concat()也不会修改调用的数组。 参数： valueN （可选） 将(多个)数组和/或值连接成新数组。 [1,2,3].concat([4,5,6],[7,8,9]) // [1, 2, 3, 4, 5, 6, 7, 8, 9] ['a','b','c'].concat(1,[2,3],[[4,5]]) // [\"a\", \"b\", \"c\", 1, 2, 3, [4,5]] // concat方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝,所以原始数组和新数组都引用相同的对象。 如果引用的对象被修改，新数组和原始数组都会变。 let obj = {a: 1}; let arr1 = [2,obj]; let arr2 = [1].concat(arr1); console.log(arr1,arr2) //[2,{a:1}],[1,2,{a:1}] //记录下上面的打印结果之后修改obj obj.a = 2; console.log(arr1,arr2) ////[2,{a:2}],[1,2,{a:2}] // 说了是浅拷贝，而且原数组也不改变，那我们就可以用它来实现数组的浅拷贝功能 let num1 = [1,2,3]; //第一种 let num2 = num1.concat(); //第二种 let num2 = [].concat(num1); num2[0] = 'a'; console.log(num1,num2); // [1, 2, 3] [\"a\", 2, 3] 返回值： 新的 Array 实例 知识点 // concat 和扩展运算符可以快速扁平化数组 const arr = [11, [22, 33], [44, 55], 66]; const flatArr = [].concat(...arr); // [11, 22, 33, 44, 55, 66] 6. isArray() 用于确定传递的值是否是一个 Array。 参数： obj 需要检测的值。 // 下面的函数调用都返回 true Array.isArray([]); Array.isArray([1]); Array.isArray(new Array()); // 这里注意：Array.prototype 也是一个数组,一个属性值不是索引的数组。[constructor: ƒ, concat: ƒ, find: ƒ, findIndex: ƒ, pop: ƒ, …] Array.isArray(Array.prototype); // 下面的函数调用都返回 false Array.isArray(); Array.isArray({}); Array.isArray(null); Array.isArray(undefined); Array.isArray(17); Array.isArray('Array'); Array.isArray(true); Array.isArray(false); Array.isArray({ __proto__: Array.prototype }); 返回值： 如果对象是 Array，则为true; 否则为false。 知识点 //判断数组的历程 // step one: 使用constructor var a = [1]; console.log(a.constructor === Array) // true // 但是原型的contructor属性是可以被改写的，例如在原型继承的时候，我们都是要把继承过来的prototype的constructor改写成我们当前的 var a = [1]; a.__proto__.constructor = '1'; console.log(a.constructor === Array) // false // step two : 使用instanceof var a = [1]; console.log(a instanceof Array) // true //但是instanceof不能检测iframes的数组 var iframe = document.createElement('iframe'); document.body.appendChild(iframe); xArray = window.frames[window.frames.length-1].Array; var arr = new xArray(1,2,3); // [1,2,3] arr instanceof Array; // false // step three :万无一失的Object.prototype.toString.call Array.isArray = function(arg) { return Object.prototype.toString.call(arg) === '[object Array]'; }; // step four : Array.isArray() var iframe = document.createElement('iframe'); document.body.appendChild(iframe); xArray = window.frames[window.frames.length-1].Array; var arr = new xArray(1,2,3); // [1,2,3] Array.isArray(arr); // true,也可以检测iframes的数组 3、数组遍历、映射、过滤、检测、简化等方法 介绍方法之前，先对这些数组方法做一个概述： 首先，大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用该函数。大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，可以忽略后两个参数。 大多数方法，第二个参数是可选的。如果有第二个参数，则调用的第一个函数参数被看做是第二个参数的方法，即当执行第一个函数参数时用作this的值(参考对象)。 方法的返回值很重要，不同的方法处理返回值的方式也不一样。 下面这些方法运行时的规则： 对于空数组是不会执行回调函数的 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数 遍历次数在第一次循环前就会确定，再添加到数组中的元素不会被遍历。 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。 已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了(例如使用 shift()) ，之后的元素将被跳过 1. forEach() 方法从头到尾遍历数组，为每个元素调用指定的函数。 参数： callback 为数组中每个元素执行的函数，该函数接收三个参数： currentValue(当前值) 数组中正在处理的当前元素。 index(索引) 数组中正在处理的当前元素的索引。 array forEach()方法正在操作的数组。 thisArg （可选） 当执行回调函数时用作this的值(参考对象)。默认值为undefined 注意： forEach无法中途退出循环，只能用return退出本次回调，进行下一次回调，如果要提前终止，可以把forEach方法放在try块中，并能抛出一个异常，但这种方法是不推荐的。 它与之后会说到的几个方法不同，总是返回 undefined值,即使你return了一个值。 // 1、 空元素不遍历,undefined和null是会遍历的。 let numberArr = [1,2,,3]; numberArr.forEach(function (value,index,array) { console.log(value,index,array) }) //打印信息如下，可见空元素是不会遍历的 //1 0 [1, 2, empty, 3] //2 1 [1, 2, empty, 3] //3 3 [1, 2, empty, 3] let nullArr = [1,2,null,3]; nullArr.forEach(function (value,index,array) { console.log(value,index,array) }) //打印信息如下，null是会遍历的 //1 0 (4) [1, 2, null, 3] //2 1 (4) [1, 2, null, 3] //null 2 (4) [1, 2, null, 3] //3 3 (4) [1, 2, null, 3] //2、已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了,之后的元素将被跳过 let numberArr = [1,2,3]; numberArr.forEach(function (value,index,array) { if(index === 0) { delete numberArr[2]; //删除第三项 //或者numberArr.pop() } console.log(value,index,array) }) //打印信息如下： // 1 0 (3) [1, 2, empty] // 2 1 (3) [1, 2, empty] let numberArr1 = [1,2,3,4]; numberArr1.forEach(function (value,index,array) { if(index === 1) { numberArr1.shift() //遍历到第二项的时候，删除第一项 } console.log(value,index,array) }) // 打印信息如下,遍历到第二项的时候，删除第一项，会跳过第三项 // 1 0 (4) [1, 2, 3, 4] // 2 1 (3) [2, 3, 4] // 4 2 (3) [2, 3, 4] // 3、forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。 let arr = [1,2,3]; arr.forEach(function (value,index,array) { if(index === 0) { arr.push('新增的不会被遍历到') arr[2] = 4; } console.log(value,index,array) }) // 1 0 (4) [1, 2, 4, \"新增的不会被遍历到\"] // 2 1 (4) [1, 2, 4, \"新增的不会被遍历到\"] // 4 2 (4) [1, 2, 4, \"新增的不会被遍历到\"] // 4、使用thisArg参数 和 箭头函数使用thisArg let arr = [1,2,3]; let obj = {arr: 'thisArg'} arr.forEach(function () { console.log(this.arr) },obj) // 打印三次 'thisArg' let arr = [1,2,3]; let obj = {arr: 'thisArg'} arr.forEach(() => { console.log(this.arr) },obj) // 打印三次 undefined // 5、forEach无法中途退出循环，只能用return退出本次回调，进行下一次回调 let arr = [1,2,3]; let result = arr.forEach((value) => { if(value == 2) { return value; } console.log(value) }) console.log(result) // undefined ，即使中间return vlaue，也还是undefined //打印value的值如下，说明return 并不能终止循环 // 1 // 3 返回值： undefined 2. map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个callback函数后返回的结果。 参数：(之前说过，大多说方法都会是这样一些参数) callback 生成新数组元素的函数，使用三个参 这个函数跟forEach()的函数不同的是，传递给map()的函数应该有返回值。 currentValue callback 的第一个参数，数组中正在处理的当前元素。 index callback 的第二个参数，数组中正在处理的当前元素的索引。 array callback 的第三个参数，map 方法被调用的数组。 thisArg (可选) 执行 callback 函数时 使用的this 值。 注意： map() 返回的是新数组，它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同索引的缺失元素(因为空值不会调用函数) let number = [1,2,3]; let doubles = number.map(function (value) { return value * 2; }) console.log(number, doubles) // [1,2,3] [2,4,6] 返回值： 一个新数组，每个元素都是回调函数的结果 知识点 不要用 map 代替 forEach,map 会创建一个新的数组，占用内存。如果你不用 map 的返回值，那你就应当使用 forEach 3. filter() 方法返回的数组元素是调用的数组的一个子集。传入的函数时用来逻辑判定的，该函数返回 true 或 false,如果返回值为true或能转化为true的值，那么传递给判断函数的元素就是这个子集的成员，它将被添加倒一个作为返回值的数组中。 参数： callback 用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。返回true表示保留该元素（通过测试），false则不保留。它接受三个参数： element 当前在数组中处理的元素 index（可选） 正在处理元素在数组中的索引 array（可选）调用了filter筛选器的数组 thisArg（可选）可选。执行 callback 时的用于 this 的值。 注意： callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。也就是说filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的，可以用这个方法压缩稀疏数组的空缺。 filter 不会改变原数组，它返回过滤后的新数组。 let number = [1,2,3,4,5,6]; let small = number.filter((value) => { return value true); console.log(arr,arr1) // 打印 [1, 2, 3, empty, 5] [1, 2, 3, 5] 返回值： 一个新的通过测试的元素的集合的数组，如果没有通过测试则返回空数组。 4. every() 方法测试数组的所有元素是否都通过了指定函数的测试。当且仅当针对数组中的所有元素调用判定函数都返回true，它才返回true。 参数： callback 用来测试每个元素的函数。 thisArg 执行 callback 时使用的 this 值。 注意： every 方法为数组中的每个元素执行一次 callback 函数，callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。every 方法在callback第一次返回false后就返回false，然后终止遍历。但如果callback一直返回true，它将会遍历整个数组，最终返回true。 空数组上调用every方法，返回 true，因为空数组没有元素，所以空数组中所有元素都符合给定的条件 every 不会改变原数组 let arr = [12,34,5,23,44]; let num = 0; let result = arr.every(function (element, index, array) { num++; return element > 10; }) console.log(result,num) // 打印 false 3 // 可见发现5这个小于10的元素后，遍历立即终止，num为3 let arr = [12,34,,23,44]; let num = 0; let result = arr.every(function (element, index, array) { num++; return element > 10; }) console.log(result,num) // 打印 true 4 // 不会遍历没有赋值的索引位置，所以num为4 let result = [].every(function (element, index, array) { return element > 10; }) console.log(result) // 打印 true 返回值： 一个布尔值，当所有的元素都符合条件才返回true，否则返回false 5. some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试。当数组中至少有一个元素调用判定函数返回true，它就返回true，当且仅当数组中的所有元素调用判定函数都返回false，它才返回false。 参数： callback 用来测试每个元素的函数 thisArg 可选 执行 callback 时使用的 this 值。 注意： some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”，这时，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。 some 被调用时不会改变数组。 空数组调用some，返回false // 一个简单的例子说明 function isBiggerThan10(element, index, array) { console.log(index) return element > 10; } [2, 5, 8, 1, 4].some(isBiggerThan10); // 返回值是false，打印的index是0,1,2,3,4 [12, 5, 8, 1, 4].some(isBiggerThan10); // 返回值是true，打印的index是0，找到符合元素之后立即返回 // 实现一个跟includes方法类似的功能 let arr = [1,2,3]; function include(value) { return arr.some((element) => { return element === value; }) } include(2) // true include(4) // false let result = [].some(function (element, index, array) { return element > 10; }) console.log(result) // 打印 false 返回值： 只要数组中的任意一个元素在回调函数中返回的是真值，就返回true，否则为false 6. reduce() 和 reduceRight() 这两个方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。reduceRight() 和 reduce() 工作原理是一样的，不同的是reduceRight() 按照数组索引从高到低（从右到左）处理数组，而不是从低到高。 参数： callback 执行数组中每个值的函数，包含四个参数： accumulator 累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。 currentValue 数组中正在处理的元素。 currentIndex (可选) 数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1。 array (可选) 调用reduce的数组 initialValue (可选) 用作第一个调用 callback的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 注意： reduce为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素，回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：调用reduce时提供initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；没有提供 initialValue，accumulator取数组中的第一个值，currentValue取数组中的第二个值。即：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。 如果数组为空且没有提供initialValue，会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。 let arr = [1,2,3,4,5]; let sum = arr.reduce((x,y) => x + y,0); console.log(sum) // 15 // 看一下initialValue传和不传的区别 let arr = [1,2,3,4,5]; arr.reduce(function (accumulator,currentValue,currentIndex,arr) { console.log(currentIndex) return accumulator + currentValue; }) // 1,2,3,4,5 没传入initialValue，索引是从1开始 arr.reduce(function (accumulator,currentValue,currentIndex,arr) { console.log(currentIndex) return accumulator + currentValue; },10) // 0,1,2,3,4,5 传入initialValue，索引从0开始 // 应用到二维数组展开 let arr = [[0, 1], [2, 3], [4, 5]].reduce( (a, b) => a.concat(b) ); console.log(arr) // [0, 1, 2, 3, 4, 5] 返回值： 函数累计处理的结果 7. indexof() 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 参数： searchElement 要查找的元素 fromIndex （可选）开始查找的位置。 如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。 如果该索引值是负值，代表相对数组末尾的偏移量，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找，注意的是，这并不改变其查找顺序，查找顺序仍然是从前向后查询数组。 如果该索引值是负值，其绝对值大于数组长度，则整个数组都将会被查询。其默认值为0。 注意： indexOf 使用严格相等（即 ===）比较 searchElement 和数组中的元素。而且indexOf()不能识别 NaN let array = [2, 5, 9]; array.indexOf(2) // 0 array.indexOf(7) // -1 array.indexOf(9, 2) // 2 array.indexOf(9, 3) // -1 array.indexOf(2, -1) // -1 array.indexOf(2, -3) // 0 array.indexOf(2, -4) // 0 let array1 = [1,2,NaN]; array1.indexOf(NaN) // -1 返回值： 首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1 8. lastIndexOf() 跟indexOf()查找方向相反，方法返回指定元素在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始 参数： searchElement 要查找的元素 fromIndex （可选）开始查找的位置。默认为数组的长度减 1，即整个数组都被查找。 如果该值大于或等于数组的长度，则整个数组会被查找。 如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。 如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 注意： lastIndexOf 使用严格相等（即 ===）比较 searchElement 和数组中的元素。而且lastIndexOf()不能识别 NaN let array = [2,5,9,2]; array.lastIndexOf(9) // 2 array.lastIndexOf('9') // -1 严格相等 array.lastIndexOf(7) // -1 array.lastIndexOf(2,4) // 3 array.lastIndexOf(2,3) // 3 array.lastIndexOf(2,2) // 0 array.lastIndexOf(2,-1) // 3 array.lastIndexOf(2,-2) // 0 array.lastIndexOf(2,-4) // 0 array.lastIndexOf(2,-5) // -1 返回值： 数组中最后一个符合元素的索引，如未找到返回-1 9. includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 ES7新增 参数： searchElement 需要查找的元素值。 fromIndex （可选） 从该索引处开始查找 searchElement。默认为 0。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。负值绝对值超过长数组度，从0开始搜索。 如果fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索。 注意： includes解决了两个indexOf的问题: indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观 [1, 2, 3].includes(2); // true [1, 2, 3].includes(4); // false [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true [1, 2, 3].includes(3, -4); // true [1, 2, NaN].includes(NaN); // true 返回值： 一个布尔值，根据情况，如果包含则返回 true，否则返回false。 10. find() 和 findIndex() find 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。findIndex 方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。(ES6新增) 参数： 这两个方法跟其他的方法类似 callback 在数组每一项上执行的函数，接收 3 个参数： element 当前遍历到的元素。 index 当前遍历到的索引。 array 数组本身。 thisArg 可选，指定 callback 的 this 参数。 注意： 这两个方法对数组中的每一项元素执行一次 callback 函数，直至有一个 callback 返回 true。在稀疏数组中，即使对于数组中不存在的条目的索引也会调用回调函数。 这意味着对于稀疏数组来说，该方法的效率要低于那些只遍历有值的索引的方法。 当找到一个callback判断为true的元素，find方法会立即返回这个元素的值，否则返回 undefined。findIndex会立即返回该元素的索引。如果回调从不返回真值，或者数组的length为0，则findIndex返回-1。 这两个方法都不会修改所调用的数组 // find let a = [1, 4, -5, 10].find((n) => n Object.is(NaN, n)); // 返回元素NaN // findIndex let a = [1, 4, -5, 10].findIndex((n) => n isNaN(n)); // 返回索引4 // 稀疏数组 let a =[1,,3,4]; let index = 0; a.find((n) => { console.log(index++) //0,1,2 第二次是empty也会调用一次，而且返回为true，立即退出 return n === 3; }) 返回值： find 方法，当某个元素通过 callback 的测试时，返回数组中的一个值，否则返回 undefined。 findIndex方法，返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 知识点 不要用 find() 代替 some(),通常混用是这种场景，find 返回第一个符合条件的值，直接拿这个值做 if 判断是否存在，但是这个符合条件的值也有可能恰好为 0。 find 是找到数组中的值后对其进一步处理，一般用于对象数组的情况；some 才是检查存在性；两者不可混用。 11. keys() 方法返回一个新的Array迭代器，它包含数组中每个索引的键。 (ES6新增) 12. values() 方法返回一个新的Array迭代器，它包含数组中每个索引的值。 (ES6新增) 13. @@iterator 属性和 values() 属性的初始值均为同一个函数对象。数组的 iterator 方法，默认情况下与 values() 返回值相同,调用语法是 arr[Symbol.iterator]() (ES6新增) 14. entries() 方法返回一个新的Array迭代器，该对象包含数组中每个索引的键/值对。 (ES6新增) 参数： 都是无。 都是一个新的 Array 迭代器对象。 for (let key of ['a', 'b'].keys()) { console.log(key); } // 0 // 1 for (let value of ['a', 'b'].values()) { console.log(value); } // 'a' // 'b' for (let value of ['a', 'b'][Symbol.iterator]()) { console.log(value); } // 'a' // 'b' for (let [key, value] of ['a', 'b'].entries()) { console.log(key, value); } // 0 \"a\" // 1 \"b\" 扩展几个概念 1、数组的索引和对象key有什么关系？ 数组是对象的特殊形式，使用方括号访问数组元素和使用方括号访问对象属性一样。JavaScript将指定的数字索引值转换成字符串——索引1变成\"1\"——然后将其作为属性名来使用。数组的特别之处在于，当使用小于2^32的非负整数作为属性名时数组会自动维护其length属性。 // 索引到属性名的转化 let arr = [1,2,3]; console.log(arr[1]) // 2 console.log(arr[\"1\"]) // 2 所有的数组都是对象，可以为其创建任意名字的属性，不过，只有在小于2^32的非负整数才是索引，数组才会根据需要更新length。事实上数组的索引仅仅是对象属性名的一种特殊类型，这意味着JavaScript数组没有“越界”错误的概念。当查询任何对象中不存在的属性时，不会报错，只会得到undefined let arr = []; arr[\"a\"] = 1; console.log(arr,arr.length) // arr是[a:1] length是0 对于使用负数或非整数的情况，数值会转换为字符串，字符串作为属性名来用，当时只能当做常规的对象属性，而非数组的索引。 let arr = []; arr[-1.23] = 0; console.log(arr,arr.length) // arr是[-1.23: 0] length是0 使用非负整数的字符串或者一个跟整数相等的浮点数时，它就当做数组的索引而非对象属性。 let arr = []; arr[\"100\"] = 'a'; console.log(arr,arr.length) // arr 是[empty × 100, \"a\"]，length 是101 let arr1 = []; arr1[1.0000] = 'b'; console.log(arr1,arr1.length) // arr 是[empty, \"b\"]，length 是2 2、稀疏数组 稀疏数组就是包含从0开始的不连续索引的数组。通常数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数 足够稀疏的数组通常在实现上比稠密的数组更慢，更耗内存，在这样的数组中查找元素所用的时间就变得跟常规对象的查找时间一样长了，失去了性能的优势。 let a1 = [,,]; // 数组直接量，该数组是[empty × 2] 0 in a1 // false: a1在索引0处没有元素 let a2 = new Array(3); //[empty × 3],该数组根本没有元素 0 in a2 // false: a2在索引0处没有元素 let a3 = [undefined]; 0 in a3 // true: a3在索引0处有一个值为undefined的元素 let a4 = [,undefined]; 0 in a4 // fasle: a4在索引0处没有元素 1 in a4 // true: a4在索引1处有一个值为undefined的元素 console.log(a4[0],a4[1]) // undefined undefined,可见数组访问返回undefined,可能是稀疏数组，也可能是数组元素为undefined 3、类数组对象 拥有一个数值length属性和对应非负整数属性的对象看做一种类型的数组 数组跟类数组相比有以下不同： 当有新元素添加到数组中时，自动更新length属性 设置length为一个较小值将截断数组 从Array.prototype中继承了一些方法 其类属性为'Array' JavaScript 数组有很多方法特意定义通用，因此他们不仅应用在真正的数组而且在类数组对象上都能正确工作，JavaScript权威指南一书说的是：ES5中所有的方法都是通用的，ES3中除了toString()和toLocaleString()意外所有方法也是通用的。 类数组对象显然没有继承自Array.prototype，所以它们不能直接调用数组方法，不过可以间接地使用Function.call方法调用。 // 类数组应用通用方法 let arrayLike = {0: 'name', 1: 'age', 2: 'address', length: 3 } Array.prototype.join.call(arrayLike,'*') // \"name*age*address\" // 还记得当初获取的DOM元素怎么转化成数组么？ functon toArray (DOM) { return Array.prototype.slice.call(DOM); } //对的，这样也可以的 let htmlCollection = document.getElementsByTagName('h2'); let arr1 = Array.prototype.map.call(htmlCollection,function (ele,index){return ele}); console.log(Array.isArray(arr1)) // true // 还有这样 let arrayLike = {0: 'name', 1: 'age', 2: 'address', length: 3 } let arr2 = Array.prototype.concat.apply([],arrayLike); console.log(arr) //[\"name\", \"age\", \"address\"] // ES6现在这样 let arrayLike = {0: 'name', 1: 'age', 2: 'address', length: 3 } let arr3 = Array.from(arrayLike); console.log(arr3) // [\"name\", \"age\", \"address\"] 4、 JavaScript数组的进化——类型化数组的引入 先说一下普遍意义上的Array,数组是一串 连续 的内存位置，用来保存某些值。JavaScript 中的数组是哈希映射，可以使用不同的数据结构来实现，如链表,上一个元素包含下一个元素的引用。这样其他语言中数组的取值是根据内存位置进行数学计算就能找到，而在JavaScript中就需要遍历链表之类的结构，数组越长，遍历链表跟数据计算相比就越慢。 现代 JavaScript 引擎是会给数组分配连续内存的 —— 如果数组是同质的（所有元素类型相同）。所以在写代码时保证数组同质，以便 JIT（即时编译器）能够使用 c 编译器式的计算方法读取元素是一种优雅的方式。 不过，一旦你想要在某个同质数组中插入一个其他类型的元素，JIT 将解构整个数组，并按照旧有的方式重新创建。 ES6 增加了 ArrayBuffer， 提供一块连续内存供我们随意操作。然而，直接操作内存还是太复杂、偏底层。于是便有了处理 ArrayBuffer 的视图（View）。 ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。 语法: new ArrayBuffer(length) 参数 length:要创建的 ArrayBuffer 的大小，单位为字节。 返回值:一个指定大小的 ArrayBuffer 对象，其内容被初始化为 0。 异常:如果 length 大于 Number.MAX_SAFE_INTEGER（>= 2 ** 53）或为负数，则抛出一个 RangeError 异常。 类型数组对象 一个TypedArray 对象描述一个底层的二进制数据缓存区的一个类似数组(array-like)视图。事实上，没有名为 TypedArray的全局对象，也没有一个名为的 TypedArray构造函数。相反，有许多不同的全局对象，下面会列出这些针对特定元素类型的类型化数组的构造函数。 new TypedArray(); // ES2017中新增 new TypedArray(length); new TypedArray(typedArray); new TypedArray(object); new TypedArray(buffer [, byteOffset [, length]]); TypedArray()指的是以下的其中之一： Int8Array();//8位二进制带符号整数 -2^7~(2^7) - 1,大小1个字节 Uint8Array();//8位无符号整数 0~(2^8) - 1,大小1个字节 Int16Array();//16位二进制带符号整数 -2^15~(2^15)-1,大小2个字节 Uint16Array();//16位无符号整数 0~(2^16) - 1,大小2个字节 Int32Array();// 32位二进制带符号整数 -2^31~(2^31)-1,大小4个字节 Uint32Array();//32位无符号整数 0~(2^32) - 1,大小4个字节 Float32Array();//32位IEEE浮点数,大小4个字节 Float64Array(); //64位IEEE浮点数,大小8个字节 应用： var buffer = new ArrayBuffer(8); var view = new Int32Array(buffer); view[0] = 100; console.log(view)// [100,0],一个八个字节，Int32Array一个元素大小是4个字节，所以只能放下两个元素 参考和链接 《JavaScript权威指南》数组部分 详解JS遍历 给初学者：JavaScript 中数组操作注意点 一次掌握 JavaScript ES5 到 ES8 数组内容 【干货】js 数组详细操作方法及解析合集 【译】 深入 JavaScript 数组：进化与性能 "},"JavaScript/utility/cache.html":{"url":"JavaScript/utility/cache.html","title":"三种本地存储方式和一些扩展","keywords":"","body":"三种本地存储方式和一些扩展 cookie 前言 网络早期最大的问题之一是如何管理状态。简而言之，服务器无法知道两个请求是否来自同一个浏览器。当时最简单的方法是在请求时，在页面中插入一些参数，并在下一个请求中传回参数。这需要使用包含参数的隐藏的表单，或者作为URL参数的一部分传递。这两个解决方案都手动操作，容易出错。cookie出现来解决这个问题。 作用 cookie是纯文本，没有可执行代码。存储数据，当用户访问了某个网站（网页）的时候，我们就可以通过cookie来向访问者电脑上存储数据，或者某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密） 如何工作 当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在cookie中”。 存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那种设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在cookie中，其他类型的数据就不适合了。 特征 不同的浏览器存放的cookie位置不一样，也是不能通用的。 cookie的存储是以域名形式进行区分的，不同的域下存储的cookie是独立的。 我们可以设置cookie生效的域（当前设置cookie所在域的子域），也就是说，我们能够操作的cookie是当前域以及当前域下的所有子域 一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数不一样,一般为20个。 每个cookie存放的内容大小也是有限制的，不同的浏览器存放大小不一样，一般为4KB。 cookie也可以设置过期的时间，默认是会话结束的时候，当时间到期自动销毁 cookie值既可以设置，也可以读取。 设置 客户端设置 document.cookie = '名字=值'; document.cookie = 'username=cfangxu;domain=baike.baidu.com' 并且设置了生效域 注意： 客户端可以设置cookie 的下列选项：expires、domain、path、secure（有条件：只有在https协议的网页中，客户端设置secure类型的 cookie 才能成功），但无法设置HttpOnly选项。 服务器端设置不管你是请求一个资源文件（如 html/js/css/图片），还是发送一个ajax请求，服务端都会返回response。而response header中有一项叫set-cookie，是服务端专门用来设置cookie的。 Set-Cookie 消息头是一个字符串，其格式如下（中括号中的部分是可选的）： Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure] 注意： 一个set-Cookie字段只能设置一个cookie，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段。服务端可以设置cookie 的所有选项：expires、domain、path、secure、HttpOnly通过 Set-Cookie 指定的这些可选项只会在浏览器端使用，而不会被发送至服务器端。 读取 我们通过document.cookie来获取当前网站下的cookie的时候，得到的字符串形式的值，它包含了当前网站下所有的cookie（为避免跨域脚本(xss)攻击，这个方法只能获取非 HttpOnly 类型的cookie）。它会把所有的cookie通过一个分号+空格的形式串联起来，例如username=chenfangxu; job=coding 修改 cookie 要想修改一个cookie，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新cookie时，path/domain这几个选项一定要旧cookie 保持一样。否则不会修改旧值，而是添加了一个新的 cookie。 删除 把要删除的cookie的过期时间设置成已过去的时间,path/domain/这几个选项一定要旧cookie 保持一样。 注意 如果只设置一个值，那么算cookie中的value; 设置的两个cookie,key值如果设置的相同，下面的也会把上面的覆盖。 cookie的属性（可选项） 过期时间 如果我们想长时间存放一个cookie。需要在设置这个cookie的时候同时给他设置一个过期的时间。如果不设置，cookie默认是临时存储的，当浏览器关闭进程的时候自动销毁 注意：document.cookie = '名称=值;expires=' + GMT(格林威治时间)格式的日期型字符串; 一般设置天数：new Date().setDate( oDate.getDate() + 5 ); 比当前时间多5天 一个设置cookie时效性的例子 function setCookie(c_name, value, expiredays){ var exdate=new Date(); exdate.setDate(exdate.getDate() + expiredays); document.cookie=c_name+ \"=\" + escape(value) + ((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString()) } 使用方法：setCookie('username','cfangxu',30) expires 是 http/1.0协议中的选项，在新的http/1.1协议中expires已经由 max-age 选项代替，两者的作用都是限制cookie 的有效时间。expires的值是一个时间点（cookie失效时刻= expires），而max-age 的值是一个以秒为单位时间段（cookie失效时刻= 创建时刻+ max-age）。另外，max-age 的默认值是 -1(即有效期为 session )；max-age有三种可能值：负数、0、正数。负数：有效期session；0：删除cookie；正数：有效期为创建时刻+ max-age cookie的域概念（domain选项） domain指定了 cookie 将要被发送至哪个或哪些域中。默认情况下，domain 会被设置为创建该 cookie 的页面所在的域名，所以当给相同域名发送请求时该 cookie 会被发送至服务器。 浏览器会把 domain 的值与请求的域名做一个尾部比较（即从字符串的尾部开始比较），并将匹配的 cookie 发送至服务器。 客户端设置 document.cookie = \"username=cfangxu;path=/;domain=qq.com\"如上：“www.qq.com\" 与 \"sports.qq.com\" 公用一个关联的域名\"qq.com\"，我们如果想让 \"sports.qq.com\" 下的cookie被 \"www.qq.com\" 访问，我们就需要用到 cookie 的domain属性，并且需要把path属性设置为 \"/\"。 服务端设置 Set-Cookie: username=cfangxu;path=/;domain=qq.com注：一定的是同域之间的访问，不能把domain的值设置成非主域的域名。 cookie的路径概念（path选项） cookie 一般都是由于用户访问页面而被创建的，可是并不是只有在创建 cookie 的页面才可以访问这个 cookie。因为安全方面的考虑,默认情况下，只有与创建 cookie 的页面在同一个目录或子目录下的网页才可以访问。 即path属性可以为服务器特定文档指定cookie，这个属性设置的url且带有这个前缀的url路径都是有效的。 客户端设置 最常用的例子就是让 cookie 在根目录下,这样不管是哪个子页面创建的 cookie，所有的页面都可以访问到了。 document.cookie = \"username=cfangxu; path=/\" 服务端设置 Set-Cookie:name=cfangxu; path=/blog 如上设置：path 选项值会与 /blog，/blogrool 等等相匹配；任何以 /blog 开头的选项都是合法的。需要注意的是，只有在 domain 选项核实完毕之后才会对 path 属性进行比较。path 属性的默认值是发送 Set-Cookie 消息头所对应的 URL 中的 path 部分。 domain和path总结： domain是域名，path是路径，两者加起来就构成了 URL，domain和path一起来限制 cookie 能被哪些 URL 访问。所以domain和path2个选项共同决定了cookie何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。domain的默认值为设置该cookie的网页所在的域名，path默认值为设置该cookie的网页所在的目录。 cookie的安全性（secure选项） 通常 cookie 信息都是使用HTTP连接传递数据，这种传递方式很容易被查看，所以 cookie 存储的信息容易被窃取。假如 cookie 中所传递的内容比较重要，那么就要求使用加密的数据传输。 secure选项用来设置cookie只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 secure 选项的 cookie 才能被发送至服务器。 document.cookie = \"username=cfangxu; secure\" 把cookie设置为secure，只保证 cookie 与服务器之间的数据传输过程加密，而保存在本地的 cookie文件并不加密。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息。机密且敏感的信息绝不应该在 cookie 中存储或传输，因为 cookie 的整个机制原本都是不安全的 注意：如果想在客户端即网页中通过 js 去设置secure类型的 cookie，必须保证网页是https协议的。在http协议的网页中是无法设置secure类型cookie的。 httpOnly 这个选项用来设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。 在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。 cookie的编码 cookie其实是个字符串，但这个字符串中等号、分号、空格被当做了特殊符号。所以当cookie的 key 和 value 中含有这3个特殊字符时，需要对其进行额外编码，一般会用escape进行编码，读取时用unescape进行解码；当然也可以用encodeURIComponent/decodeURIComponent或者encodeURI/decodeURI，查看关于编码的介绍 第三方cookie 通常cookie的域和浏览器地址的域匹配，这被称为第一方cookie。那么第三方cookie就是cookie的域和地址栏中的域不匹配，这种cookie通常被用在第三方广告网站。为了跟踪用户的浏览记录，并且根据收集的用户的浏览习惯，给用户推送相关的广告。关于第三方cookie和cookie的安全问题可以查看https://mp.weixin.qq.com/s/oOGIuJCplPVW3BuIx9tNQg cookie推荐资源 聊一聊 cookie HTTP cookies 详解 --- localStorage（本地存储） HTML5新方法，不过IE8及以上浏览器都兼容。 特点 生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 存储的信息在同一域中是共享的。 当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。 大小：据说是5M（跟浏览器厂商有关系） 在非IE下的浏览中可以本地打开。IE浏览器要在服务器中打开。 localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 localStorage受同源策略的限制 设置 localStorage.setItem('username','cfangxu'); 获取 localStorage.getItem('username')也可以获取键名localStorage.key(0) #获取第一个键名 删除 localStorage.removeItem('username')也可以一次性清除所有存储localStorage.clear() storage事件 当storage发生改变的时候触发。注意： 当前页面对storage的操作会触发其他页面的storage事件事件的回调函数中有一个参数event,是一个StorageEvent对象，提供了一些实用的属性,如下表： Property Type Description key String The named key that was added, removed, or moddified oldValue Any The previous value(now overwritten), or null if a new item was added newValue Any The new value, or null if an item was added url/uri String The page that called the method that triggered this change --- sessionStorage 其实跟localStorage差不多，也是本地存储，会话本地存储 特点： 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁，或者在新窗口打开同源的另一个页面，sessionStorage也是没有的。 --- cookie、localStorage、sessionStorage区别 相同：在本地（浏览器端）存储数据 不同： localStorage、sessionStorage localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。 sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。 localStorage是永久存储，除非手动删除。 sessionStorage当会话结束（当前页面关闭的时候，自动销毁） cookie的数据会在每一次发送http请求的时候，同时发送给服务器而localStorage、sessionStorage不会。 扩展其他的前端存储方式（不常用） web SQL database 先说个会被取代的，为什么会被取代，主要有以下几个原因： W3C舍弃 Web SQL database草案,而且是在2010年年底，规范不支持了，浏览器厂商已经支持的就支持了，没有支持的也不打算支持了，比如IE和Firefox。 为什么要舍弃？因为 Web SQL database 本质上是一个关系型数据库，后端可能熟悉，但是前端就有很多不熟悉了，虽然SQL的简单操作不难，但是也得需要学习。 SQL熟悉后，真实操作中还得把你要存储的东西，比如对象，转成SQL语句，也挺麻烦的。 indexedDB 来自MDN的解释： indexedDB 是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。 所以，IndexedDB API是强大的，但对于简单的情况可能看起来太复杂了，所以要看你的业务场景来选择到底是用还是不用。 indexedDB 是一个基于JavaScript的面向对象的数据库。 IndexedDB允许你存储和检索用键索引的对象; IndexedDB 鼓励使用的基本模式如下所示： 打开数据库并且开始一个事务。 创建一个 object store。 构建一个请求来执行一些数据库操作，像增加或提取数据等。 通过监听正确类型的 DOM 事件以等待操作完成。 在操作结果上进行一些操作（可以在 request 对象中找到） 1、首先打开indexedDB数据库 语法：window.indexedDB.open(dbName, version) var db; // 打开数据库,open还有第二个参数版本号 var request = window.indexedDB.open('myTestDatabase'); // 数据库打开成功后 request.onsuccess = function (event) { // 存储数据结果,后面所有的数据库操作都离不开它。 db = request.result; } request.onerror = function (event) { alert(\"Why didn't you allow my web app to use IndexedDB?!\"); } // 数据库首次创建版本，或者window.indexedDB.open传递的新版本（版本数值要比现在的高） request.onupgradeneeded = function (event) { } onupgradeneeded事件： 更新数据库的 schema，也就是创建或者删除对象存储空间，这个事件将会作为一个允许你处理对象存储空间的 versionchange 事务的一部分被调用。在数据库第一次被打开时或者当指定的版本号高于当前被持久化的数据库的版本号时，这个 versionchange 事务将被创建。onupgradeneeded 是我们唯一可以修改数据库结构的地方。在这里面，我们可以创建和删除对象存储空间以及构建和删除索引。 2、构建数据库 IndexedDB 使用对象存储空间而不是表，并且一个单独的数据库可以包含任意数量的对象存储空间。每当一个值被存储进一个对象存储空间时，它会被和一个键相关联。 // 数据库首次创建版本，或者window.indexedDB.open传递的新版本（版本数值要比现在的高） request.onupgradeneeded = function (event) { //之前咱们不是在success中得到了db了么，为什么还要在这获取， //因为在当前事件函数执行后才会去执行success事件 var db = event.target.result; // 创建一个对象存储空间，keyPath是id，keyGenerator是自增的 var objectStore = db.createObjectStore('testItem',{keyPath: 'id',autoIncrement: true}); // 创建一个索引来通过id搜索，id是自增的，不会有重复，所以可以用唯一索引 objectStore.createIndex('id','id',{unique: true}) objectStore.createIndex('name','name'); objectStore.createIndex('age','age'); //添加一条信息道数据库中 objectStore.add({name: 'cfangxu', age: '27'}); } 注意： 执行完后，在调试工具栏Application的indexedDB中也看不到，你得右键刷新一下。 创建索引的语法： objectStore.createIndex(indexName, keyPath, objectParameters) indexName:创建的索引名称，可以使用空名称作为索引。 keyPath:索引使用的关键路径，可以使用空的keyPath, 或者keyPath传为数组keyPath也是可以的。 objectParameters:可选参数。常用参数之一是unique，表示该字段值是否唯一，不能重复。例如，本demo中id是不能重复的，于是有设置： 3、添加数据 上面的代码建好了字段，并且添加了一条数据，但是我们如果想在onupgradeneeded事件外面操作，接下来的步骤了。由于数据库的操作都是基于事务（transaction）来进行，于是，无论是添加编辑还是删除数据库，我们都要先建立一个事务（transaction），然后才能继续下面的操作。语法： var transaction = db.transaction(dbName, \"readwrite\");第一个参数是事务希望跨越的对象存储空间的列表，可以是数组或者字符串。如果你希望事务能够跨越所有的对象存储空间你可以传入一个空数组。如果你没有为第二个参数指定任何内容，你得到的是只读事务。因为这里我们是想要写入所以我们需要传入 \"readwrite\" 标识。 var timer = setInterval(function () { if(db) { clearInterval(timer); // 新建一个事务 var transaction = db.transaction(['testItem'], 'readwrite'); // 打开一个存储对象 var objectStore = transaction.objectStore('testItem'); // 添加数据到对象中 objectStore.add({ name: 'xiaoming', age: '12' }); objectStore.add({ name: 'xiaolong', age: '20' }); } },100) 为什么要用一个间隔定时器？ 因为这是一个demo，正常的是要有操作才能进行数据库的写入，在我们的demo中，js执行到transaction会比indexedDB的onsuccess事件回调快，导致会拿到db为undefined，所以写了个间隔定时器等它一会。 4、获取数据 var transaction = db.transaction(['testItem'], 'readwrite'); var objectStore = transaction.objectStore('testItem'); var getRquest = objectStore.get(1); getRquest.onsuccess = function (event) { console.log(getRquest.result); } //输出：{name: \"cfangxu\", age: \"27\", id: 1} 5、修改数据 var transaction = db.transaction(['testItem'], 'readwrite'); var objectStore = transaction.objectStore('testItem'); var getRquest = objectStore.put({ name: 'chenfangxu', age: '27', id:1 }); // 修改了id为1的那条数据 6、删除数据 var transaction = db.transaction(['testItem'], 'readwrite'); var objectStore = transaction.objectStore('testItem'); var getRquest = objectStore.delete(1); // 删除了id为1的那条数据 上面的例子执行完后，一定一定要右键刷新indexedDB,它自己是不会变的。 关于数据库的名词解释和indexedDB的游标介绍参阅：HTML5 indexedDB前端本地存储数据库实例教程 张大神的文中没有指出新手要踩的坑，我踩完也说明了。 "},"JavaScript/utility/module.html":{"url":"JavaScript/utility/module.html","title":"JavaScript的模块","keywords":"","body":"JavaScript的模块 介绍 模块通常是指编程语言所提供的代码组织机制，利用此机制可将程序拆解为独立且通用的代码单元。 模块化这个词最早出现在一本研究工程设计的探路性质的书《Design Rules》中。 软件模块化是随着软件的复杂性诞生的。模块化的意义在于降低软件的复杂性，不至于随着软件或系统变大而不可控，使其可控，可维护，可扩展。 无论那种语言，封装是写模块的首要特质。即模块不会暴露自身的实现细节，不会调用其它模块的实现代码，不会共享全局变量。一切只靠接口通信。模块化和封装是密不可分的 所谓模块化主要是解决代码分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等多个方面。 模块的优点 可维护性。 因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。 命名空间。 在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境。 重用代码。 我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库。我们可以在更新了模块之后，让引用了该模块的所有项目都同步更新，还能指定版本号，避免 API 变更带来的麻烦。 CommonJS CommonJS 最开始是 Mozilla 的工程师于 2009 年开始的一个项目，它的目的是让浏览器之外的 JavaScript （比如服务器端或者桌面端）能够通过模块化的方式来开发和协作。 在 CommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。 需要注意的是，CommonJS 规范的主要适用场景是服务器端编程，所以采用同步加载模块的策略。如果我们依赖3个模块，代码会一个一个依次加载它们。 该模块实现方案主要包含 require 与 module 这两个关键字，其允许某个模块对外暴露部分接口并且由其他模块导入使用。 //sayModule.js function SayModule () { this.hello = function () { console.log('hello'); }; this.goodbye = function () { console.log('goodbye'); }; } module.exports = SayModule; //main.js 引入sayModule.js var Say = require('./sayModule.js'); var sayer = new Say(); sayer.hello(); //hello 作为一个服务器端的解决方案，CommonJS 需要一个兼容的脚本加载器作为前提条件。该脚本加载器必须支持名为 require 和 module.exports 的函数，它们将模块相互导入导出。 Node.js Node 从 CommonJS 的一些创意中，创造出自己的模块化实现。由于Node 在服务端的流行，Node 的模块形式被（不正确地）称为 CommonJS。 Node.js模块可以分为两大类，一类是核心模块，另一类是文件模块。核心模块 就是Node.js标准的API中提供的模块，如fs、http、net等，这些都是由Node.js官方提供的模块，编译成了二进制代码，可以直接通过require获取核心模块，例如require('fs')，核心模块拥有最高的加载优先级，如果有模块与核心模块命名冲突，Node.js总是会加载核心模块。文件模块 是存储为单独的文件（或文件夹）的模块，可能是JavaScript代码、JSON或编译好的C/C++代码。在不显式指定文件模块扩展名的时候，Node.js会分别试图加上.js、.json、.node(编译好的C/C++代码)。 加载方式 按路径加载模块如果require参数以\"/\"开头，那么就以绝对路径的方式查找模块名称，如果参数以\"./\"、\"../\"开头，那么则是以相对路径的方式来查找模块。 通过查找node_modules目录加载模块如果require参数不以\"/\"、\"./\"、\"../\"开头，而该模块又不是核心模块，那么就要通过查找node_modules加载模块了。我们使用的npm获取的包通常就是以这种方式加载的。 加载缓存 Node.js模块不会被重复加载，这是因为Node.js通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了。注意： Node.js是根据实际文件名缓存的，而不是require()提供的参数缓存的，也就是说即使你分别通过require('express')和require('./node_modules/express')加载两次，也不会重复加载，因为尽管两次参数不同，解析到的文件却是同一个。 Node.js 中的模块在加载之后是以单例化运行，并且遵循值传递原则：如果是一个对象，就相当于这个对象的引用。 模块载入过程 加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。 例如运行： node app.js Module.runMain = function () { // Load the main module--the command line argument. Module._load(process.argv[1], null, true); }; //_load静态方法在分析文件名之后执行 var module = new Module(id, parent); //并根据文件路径缓存当前模块对象，该模块实例对象则根据文件名加载。 module.load(filename); 具体说一下上文提到了文件模块的三类模块,这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法，具体的加载方法在下文require.extensions中会介绍。 .js 通过fs模块同步读取js文件并编译执行。 .node 通过C/C++进行编写的Addon。通过dlopen方法进行加载。 .json 读取文件，调用JSON.parse解析加载。 接下来详细描述js后缀的编译过程。Node.js在编译js文件的过程中实际完成的步骤有对js文件内容进行头尾包装。以app.js为例，包装之后的app.js将会变成以下形式： //circle.js var PI = Math.PI; exports.area = function (r) { return PI * r * r; }; exports.circumference = function (r) { return 2 * PI * r; }; //app.js var circle = require('./circle.js'); console.log( 'The area of a circle of radius 4 is ' + circle.area(4)); //app包装后 (function (exports, require, module, __filename, __dirname) { var circle = require('./circle.js'); console.log('The area of a circle of radius 4 is ' + circle.area(4)); }); //这段代码会通过vm原生模块的runInThisContext方法执行（类似eval，只是具有明确上下文，不污染全局），返回为一个具体的function对象。最后传入module对象的exports，require方法，module，文件名，目录名作为实参并执行。 这就是为什么require并没有定义在app.js 文件中，但是这个方法却存在的原因。从Node.js的API文档中可以看到还有__filename、__dirname、module、exports几个没有定义但是却存在的变量。其中__filename和__dirname在查找文件路径的过程中分析得到后传入的。module变量是这个模块对象自身，exports是在module的构造函数中初始化的一个空对象（{}，而不是null）。在这个主文件中，可以通过require方法去引入其余的模块。而其实这个require方法实际调用的就是module._load方法。load方法在载入、编译、缓存了module后，返回module的exports对象。这就是circle.js文件中只有定义在exports对象上的方法才能被外部调用的原因。 以上所描述的模块载入机制均定义在lib/module.js中。 require 函数 require 引入的对象主要是函数。当 Node 调用 require() 函数，并且传递一个文件路径给它的时候，Node 会经历如下几个步骤： Resolving：找到文件的绝对路径； Loading：判断文件内容类型； Wrapping：打包，给这个文件赋予一个私有作用范围。这是使 require 和 module 模块在本地引用的一种方法； Evaluating：VM 对加载的代码进行处理的地方； Caching：当再次需要用这个文件的时候，不需要重复一遍上面步骤。 require.extensions 来查看对三种文件的支持情况 可以清晰地看到 Node 对每种扩展名所使用的函数及其操作：对 .js 文件使用 module._compile；对 .json 文件使用 JSON.parse；对 .node 文件使用 process.dlopen。 文件查找策略 从文件模块缓存中加载尽管原生模块与文件模块的优先级不同，但是优先级最高的是从文件模块的缓存中加载已经存在的模块。 从原生模块加载 原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http、http.js、http.node、http.json文件，require(“http”)都不会从这些文件中加载，而是从原生模块中加载。原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。 从文件加载当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前面说过是调用load方法。 ·· 当 Node 遇到 require(X) 时，按下面的顺序处理。 （1）如果 X 是内置模块（比如 require('http'）) 　　a. 返回该模块。 　　b. 不再继续执行。 （2）如果 X 以 \"./\" 或者 \"/\" 或者 \"../\" 开头 　　a. 根据 X 所在的父模块，确定 X 的绝对路径。 　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。 X X.js X.json X.node 　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。 X/package.json（main字段） X/index.js X/index.json X/index.node （3）如果 X 不带路径 　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。 　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。 （4） 抛出 \"not found\" 模块循环依赖 //创建两个文件，module1.js 和 module2.js，并且让它们相互引用 // module1.js exports.a = 1; require('./module2'); exports.b = 2; exports.c = 3; // module2.js const Module1 = require('./module1'); console.log('Module1 is partially loaded here', Module1); //执行 node module2.js 打印： {a:1,b:2,c:3} //执行 node module1.js 打印： {a:1} 在 module1 完全加载之前需要先加载 module2，而 module2 的加载又需要 module1。这种状态下，我们从 exports 对象中能得到的就是在发生循环依赖之前的这部分。上面代码中，只有 a 属性被引入，因为 b 和 c 都需要在引入 module2 之后才能加载进来。 Node 使这个问题简单化，在一个模块加载期间开始创建 exports 对象。如果它需要引入其他模块，并且有循环依赖，那么只能部分引入，也就是只能引入发生循环依赖之前所定义的这部分。 AMD AMD 是 Asynchronous Module Definition 的简称，即“异步模块定义”，是从 CommonJS 讨论中诞生的。AMD 优先照顾浏览器的模块加载场景，使用了异步加载和回调的方式。 AMD 和 CommonJS 一样需要脚本加载器，尽管 AMD 只需要对 define 方法的支持。define 方法需要三个参数：模块名称，模块运行的依赖数组，所有依赖都可用之后执行的函数（该函数按照依赖声明的顺序，接收依赖作为参数）。只有函数参数是必须的。define 既是一种引用模块的方式，也是定义模块的方式。 // file lib/sayModule.js define(function (){ return { sayHello: function () { console.log('hello'); } }; }); //file main.js define(['./lib/sayModule'], function (say){ say.sayHello(); //hello }) main.js 作为整个应用的入口模块，我们使用 define 关键字声明了该模块以及外部依赖(没有生命模块名称)；当我们执行该模块代码时，也就是执行 define 函数的第二个参数中定义的函数功能，其会在框架将所有的其他依赖模块加载完毕后被执行。这种延迟代码执行的技术也就保证了依赖的并发加载。 RequireJS RequireJS 是一个前端的模块化管理的工具库，遵循AMD规范,通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新的函数（模块），我们所有的关于新模块的业务代码都在这个函数内部操作，其内部也可无限制的使用已经加载进来的以来的模块。 //scripts下的main.js则是指定的主代码脚本文件，所有的依赖模块代码文件都将从该文件开始异步加载进入执行。 defined用于定义模块，RequireJS要求每个模块均放在独立的文件之中。按照是否有依赖其他模块的情况分为独立模块和非独立模块。1、独立模块 不依赖其他模块。直接定义 define({ methodOne: function (){}, methodTwo: function (){} }); //等价于 define(function (){ return { methodOne: function (){}, methodTwo: function (){} }; }); 2、非独立模块，对其他模块有依赖 define([ 'moduleOne', 'moduleTwo' ], function(mOne, mTwo){ ... }); //或者 define( function( require ){ var mOne = require( 'moduleOne' ), mTwo = require( 'moduleTwo' ); ... }); 如上代码， define中有依赖模块数组的 和 没有依赖模块数组用require加载 这两种定义模块，调用模块的方法合称为AMD模式，定义模块清晰，不会污染全局变量，清楚的显示依赖关系。AMD模式可以用于浏览器环境并且允许非同步加载模块，也可以按需动态加载模块。 CMD CMD（Common Module Definition），在CMD中，一个模块就是一个文件。 全局函数define，用来定义模块。参数 factory 可以是一个函数，也可以为对象或者字符串。当 factory 为对象、字符串时，表示模块的接口就是该对象、字符串。 定义JSON数据模块： define({ \"foo\": \"bar\" }); factory 为函数的时候，表示模块的构造方法，执行构造方法便可以得到模块向外提供的接口。 define( function(require, exports, module) { // 模块代码 }); SeaJS sea.js 核心特征： 遵循CMD规范，与NodeJS般的书写模块代码。 依赖自动加载，配置清晰简洁。 seajs.use 用来在页面中加载一个或者多个模块 // 加载一个模块 seajs.use('./a'); // 加载模块，加载完成时执行回调 seajs.use('./a'，function(a){ a.doSomething(); }); // 加载多个模块执行回调 seajs.use(['./a','./b']，function(a , b){ a.doSomething(); b.doSomething(); }); AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同。很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。 为什么说是执行时机处理不同？同样都是异步加载模块，AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。 UMD 统一模块定义（UMD：Universal Module Definition ）就是将 AMD 和 CommonJS 合在一起的一种尝试，常见的做法是将CommonJS 语法包裹在兼容 AMD 的代码中。 (function(define) { define(function () { return { sayHello: function () { console.log('hello'); } }; }); }( typeof module === 'object' && module.exports && typeof define !== 'function' ? function (factory) { module.exports = factory(); } : define )); 该模式的核心思想在于所谓的 IIFE（Immediately Invoked Function Expression），该函数会根据环境来判断需要的参数类别 ES6模块(module) 严格模式 ES6 的模块自动采用严格模式，不管有没有在模块头部加上\"use strict\";。严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 模块Module 一个模块，就是一个对其他模块暴露自己的属性或者方法的文件。 导出Export 作为一个模块，它可以选择性地给其他模块暴露（提供）自己的属性和方法，供其他模块使用。 // profile.js export var firstName = 'chen'; export var lastName = 'fangxu'; export var year = 1991; //等价于 var firstName = 'chen'; var lastName = 'fangxu'; var year = 1991; export {firstName, lastName, year} 1、 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 function v1() { ... } function v2() { ... } export { v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion }; //上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。 2、 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 // 报错 export 1; // 报错 var m = 1; export m; //上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。 // 写法一 export var m = 1; // 写法二 var m = 1; export {m}; // 写法三 var n = 1; export {n as m}; //上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。 3、最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，接下来说的import命令也是如此。 function foo() { export default 'bar' // SyntaxError } foo() 导入import 作为一个模块，可以根据需要，引入其他模块的提供的属性或者方法，供自己模块使用。 1、 import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 import { lastName as surename } from './profile'; 2、import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 3、注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。 foo(); import { foo } from 'my_module'; //上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 4、由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 // 报错 import { 'f' + 'oo' } from 'my_module'; // 报错 let module = 'my_module'; import { foo } from module; // 报错 if (x === 1) { import { foo } from 'module1'; } else { import { foo } from 'module2'; } 5、最后，import语句会执行所加载的模块，因此可以有下面的写法。 import 'lodash'; //上面代码仅仅执行lodash模块，但是不输出任何值。 默认导出(export default) 每个模块支持我们导出一个没有名字的变量，使用关键语句export default来实现. export default function(){ console.log(\"I am default Fn\"); } //使用export default关键字对外导出一个匿名函数，导入这个模块的时候，可以为这个匿名函数取任意的名字 //取任意名字均可 import sayDefault from \"./module-B.js\"; sayDefault(); //结果：I am default Fn 1、默认输出和正常输出的比较 // 第一组 export default function diff() { // 输出 // ... } import diff from 'diff'; // 输入 // 第二组 export function diff() { // 输出 // ... }; import {diff} from 'diff'; // 输入 //上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。 2、因为export default本质是将该命令后面的值，赋给default变量以后再默认，所以直接将一个值写在export default之后。 / 正确 export default 42; // 报错 export 42; //上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定外对接口为default。 3、如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。 import _, { each } from 'lodash'; //对应上面代码的export语句如下 export default function (){ //... } export function each (obj, iterator, context){ //... } export 与 import 的复合写法 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 export { foo, bar } from 'my_module'; // 等同于 import { foo, bar } from 'my_module'; export { foo, bar }; / 接口改名 export { foo as myFoo } from 'my_module'; // 整体输出 export * from 'my_module'; 注意事项1、声明的变量，对外都是只读的。但是导出的是对象类型的值，就可修改。2、导入不存在的变量，值为undefined。 ES6 中的循环引用 ES6 中，imports 是 exports 的只读视图，直白一点就是，imports 都指向 exports 原本的数据，比如： //------ lib.js ------ export let counter = 3; export function incCounter() { counter++; } //------ main.js ------ import { counter, incCounter } from './lib'; // The imported value `counter` is live console.log(counter); // 3 incCounter(); console.log(counter); // 4 // The imported value can’t be changed counter++; // TypeError 因此在 ES6 中处理循环引用特别简单，看下面这段代码： //------ a.js ------ import {bar} from 'b'; // (1) export function foo() { bar(); // (2) } //------ b.js ------ import {foo} from 'a'; // (3) export function bar() { if (Math.random()) { foo(); // (4) } } 假设先加载模块 a，在模块 a 加载完成之后，bar 间接性地指向的是模块 b 中的 bar。无论是加载完成的 imports 还是未完成的 imports，imports 和 exports 之间都有一个间接的联系，所以总是可以正常工作。 实例 //---module-B.js文件--- //导出变量：name export var name = \"cfangxu\"; moduleA模块代码： //导入 模块B的属性 name import { name } from \"./module-B.js\"; console.log(name) //打印结果：cfangxu 批量导出 //属性name var name = \"cfangxu\"; //属性age var age = 26; //方法 say var say = function(){ console.log(\"say hello\"); } //批量导出 export {name,age,say} 批量导入 //导入 模块B的属性 import { name,age,say } from \"./module-B.js\"; console.log(name) //打印结果：cfangxu console.log(age) //打印结果：26 say() //打印结果：say hello 重命名导入变量 import {name as myName} from './module-B.js'; console.log(myName) //cfangxu 整体导入 /使用*实现整体导入 import * as obj from \"./module-B.js\"; console.log(obj.name) //结果：\"cfangxu\" console.log(obj.age) //结果：26 obj.say(); //结果：say hello 推荐资料 JavaSript模块规范 - AMD规范与CMD规范介绍 JavaScript 模块演化简史 require() 源码解读 在 Node.js 中引入模块：你所需要知道的一切都在这里 深入浅出Node.js（三）：深入Node.js的模块机制 "},"JavaScript/utility/oo.html":{"url":"JavaScript/utility/oo.html","title":"JavaScript的面向对象","keywords":"","body":"JavaScript的面向对象 JavaScript的对象 对象是JavaScript的一种数据类型。对象可以看成是属性的无序集合，每个属性都是一个键值对，属性名是字符串，因此可以把对象看成是从字符串到值的映射。这种数据结构在其他语言中称之为“散列(hash)”、“字典(dictionary)”、“关联数组(associative array)”等。 原型式继承：对象不仅仅是字符串到值的映射，除了可以保持自有的属性，JavaScript对象还可以从一个称之为原型的对象继承属性，对象的方法通常是继承的属性，这是JavaScript的核心特征。 JavaScript对象是动态的—可以新增属性也可以删除属性，但是他们常用来模拟静态以及静态类型语言中的“结构体” 创建对象 1、对象直接量 创建对象最简单的方式就是在JavaScript代码中使用对象直接量。 var book = { \"main title\": 'guide', //属性名字里有空格，必须加引号 \"sub-title\": 'JS', //属性名字里有连字符，必须加引号 for: 'development', //for是关键字，不过从ES5开始，作为属性名关键字和保留字可以不加引号 author: { firstname: 'David', //这里的属性名就都没有引号 surname: 'Flanagan' } } 注意： 从ES5开始，对象直接量中的最后一个属性后的逗号将被忽略。 扩展： JavaScript中的关键字和保留字 2、通过new创建对象 new 运算符创建并初始化一个新对象。关键字new后跟一个函数调用。这里的函数称做构造函数(constructor)，构造函数用以初始化一个新创建的对象。JavaScript中的数据类型都包含内置的构造函数。 var o = new Object(); //创建一个空对象，和{}一样。var arr = new Array(); //创建一个空数组，和[]一样。 扩展 1：new new 是一个一元运算符，专门运算函数的。new后面调用的函数叫做构造函数，构造函数new的过程叫做实例化。当new去调用一个函数 : 这个时候函数中的this就指向创建出来的对象,而且函数的的返回值直接就是this(隐式返回)有一个默认惯例就是构造函数的名字首字母大写。 注意：当return的时候，如果是后面为简单类型，那么返回值还是这个对象；如果return为对象类型，那么返回的就是return后面的这个对象。 扩展 2：基本类型和对象类型（复杂类型）的区别 赋值：基本类型 : 赋值的时候只是值的复制对象类型 : 赋值不仅是值的复制，而且也是引用的传递（可以理解为内存地址）可以理解为赋址。 比较相等基本类型 : 值相同就可以对象类型 : 值和引用都相同才行 扩展 3：原型 prototype 每一个JavaScript对象(null除外)都和另一个对象相关联，这个对象就是原型，每一个对象都从原型继承属性。 3、Object.create() Object.create() 这个方法是ES5定义的，它创建一个新对象，其中第一个参数是这个对象的原型。第二个参数是可选参数，用以对对象属性进行进一步描述。 可以通过传入参数 null 创建一个没有原型的新对象，不过这个新对象不会继承任何东西，甚至不包括基础方法。var o = Object.create(null); //o不会继承任何属性和方法,空空的。 如果想创建一个普通的空对象，需要传入Object.prototypevar o = Object.create(Object.prototype); //o相当于{} 对象属性的获取和设置 可以通过点(.)或方括号([])运算符来获取和设置属性的值。 var author = book.author; var title = book[\"main title\"]; 在JavaScript中能用 . 连接的都可以用 []连接。有很多 . 运算符不能用的时候，就需要用[]代替。1、在属性名可变的情况下用[] function getAttr (obj, attr) { console.log(obj[attr]) } 2、属性名有空格或者连字符等时用[]var title = book[\"main title\"]; 删除属性 delete运算符可以删除对象的属性。delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性，如果删除的属性是个对象，那么这个对象的引用还是存在的。 var a = {b:{c:1}}; var b = a.b; console.log(b.c); // 1 console.log(a.b); // {c:1} delete a.b; console.log(b.c); // 1 console.log(a.b); //undefined delete只能删除自有属性，不能删除继承属性。 返回值 返回值为true 当delete表达式删除成功或没有任何副作用(比如删除不存在的属性)，或者delete后不是一个属性访问表达式，delete会返回 true ； var a = {b:{c:1}}; console.log(delete a.b); console.log(delete a.b); console.log(delete a.toString); console.log(delete 1); 以上都会打印true 返回值为false delete不能删除那些可配置性为false的属性，例如某些内置对象的属性是不可配置的，通过变量声明和函数声明创建的全局对象的属性。 var a = {}; Object.defineProperty(a,'b',{ value:1, configurable: false // 设置为不可配置 }) console.log(delete a.b) console.log(delete Object.prototype) var x = 1; console.log(delete this.x); console.log(delete x) 以上打印都为false 检测属性 in 运算符 in 运算符的左侧是属性名(字符串),右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回true。 var a = {b:1}; console.log('a' in window); // true 声明的全局变量'a'是window的属性 console.log('b' in a); // true 'b'是a的属性 console.log('toString' in a); // true a继承了toString属性 console.log('c' in a); // false 'c'不是a的属性 跟in运算符类似的，还可以用\"!==\"判断一个属性是否是undefined，但是有一种场景只能使用in运算符，in可以区分不存在的属性和存在但值为undefined的属性。 var a = {b:undefined}; console.log(a.b !== undefined); //false console.log(a.c !== undefined); //false console.log('b' in a); //true console.log('c' in a); //false hasOwnProperty 对象的hasOwnProperty()方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回false var a = {b:1}; console.log(a.hasOwnProperty('b')); //true console.log(a.hasOwnProperty('c')); //false console.log(a.hasOwnProperty('toString')); //false toString是继承属性 propertyIsEnumerable 对象的propertyIsEnumerable()方法只有检测到是自身属性(不包括继承的属性)且这个属性的可枚举性为true时它才返回true。 var a = {b:1}; console.log(a.propertyIsEnumerable('b')); console.log(a.propertyIsEnumerable('toString')); 包装对象 当使用原始类型的值（string、number、boolean），在调用对应属性和方法的时候，内部会自动转成对应的对象。隐式创建的这个对象，就成为包装对象。基本类型都有自己对应的包装对象 : String Number Boolean 包装对象的特点隐式创建对象后，可以调用对应的属性和方法使用后，立马销毁，所以不能给原始类型的值添加属性和方法 其过程举例：str.substring - > new String(1234) - > 找到String的substring -> 将new String销毁 对象方法和属性的汇总 Object静态方法 Object.assign() Object.create() Object.defineProperty() Object.defineProperties() Object.entries() Object.preventExtensions() Object.isExtensible() Object.seal() Object.isSealed() Object.freeze() Object.isFrozen() Object.keys() Object.values() Object.getPrototypeOf() Object.getOwnPropertyNames() Object.getOwnPropertyDescriptor() Object.getOwnPropertyDescriptors() Object的实例方法(定义在Object.prototype上的) Object.prototype.hasOwnProperty() Object.prototype.isPrototypeOf() Object.prototype.propertyIsEnumerable() Object.prototype.toString() Object.prototype.valueOf() 面向对象 编码思想 两种编程方式：(1)、面向过程(2)、面向对象 两者的区别：面向过程：关注实现过程和每一步的实现细节。面向对象：关注特征和功能。 面向对象编程 通俗点，用对象的思想写代码就是面向对象编程。 基本特征 1、抽象：抓住核心问题（简单理解为抽出像的部分；将相同或表现与问题相关特征的内容提取出来。）其核心：抽出、抽离，将相同的部分（可能会维护、会迭代、会扩展）的代码抽离出来形成一类 2、封装：就是将类的属性包装起来，不让外界轻易知道它内部的具体实现；只提供对外接口以供调用 3、继承：从已有对象上继承出新的对象 4、多态：一个对象的不同形态 面向对象的好处 1、代码的层次结构更清晰2、更容易复用3、更容易维护4、更容易扩展 面向对象相关的属性和概念 __proto__属性原型链,实例对象与原型之间的连接，叫做原型链。 对象身上只有 __proto__ 构造函数身上有prototype也有 __proto__ constructor返回创建实例对象的构造函数的引用,每个原型都会自动添加constructor属性,for..in..遍历原型是找不到这个属性的。 var a = new A(); console.log(a.constructor == A) //true hasOwnProperty可以用来判断某属性是不是这个构造函数的内部属性（不包括继承的） 语法： obj.hasOwnProperty(prop) 返回Boolean function A (){ this.b = 1; } var a = new A(); console.log(a.hasOwnProperty('b')); //打印true console.log(a.hasOwnProperty('toString')); //toString是继承属性 打印 false console.log(a.hasOwnProperty('hasOwnProperty')); //同上，打印false instanceof二元运算符,用来检测一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 语法： object instanceof constructor 即检测 constructor.prototype 是否存在于参数 object 的原型链上。 // 定义构造函数 function C(){} function D(){} var o = new C(); o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype o instanceof D; // false，因为 D.prototype不在o的原型链上 o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true C.prototype instanceof Object // true,同上 toString返回一个表示该对象的字符串 作用：1、进行数字之间的进制转换 例如：var num = 255; alert( num.toString(16) ); //结果就是'ff' 2、利用toString做类型的判断 例如：var arr = []; alert( Object.prototype.toString.call(arr) == '[object Array]' ); 弹出true Object.prototype.toString.call() 得到是类似于'[object Array]' '[object Object]' 面向对象的写法历程 1、原始模式 假如我们有一个对象是狗的原型，这个原型有“名字”和“颜色”两个属性。 var Dog = { name: '', color: '' } 根据这个原型对象，我们要生成一个实例对象如下 var hashiqi = {}; //创建空对象，之后根据原型对象的相应属性赋值 hashiqi.name = 'hashiqi'; hashiqi.color = 'blackandwhite'; 缺点：1、如果要生成多个实例对象，要重复写多次。2、实例和原型之间没有联系。 2、工厂模式 上面原始模式有一个缺点是要很麻烦的写很多重复的代码，我们可以写一个函数来解决代码重复的问题。 function Dog(name, color) { var obj = {}; obj.name = name; obj.color = color; return obj; } var hashiqi = Dog('hashiqi', 'blackandwhite'); var jinmao = Dog('jinmao', 'yellow'); 这种方式只是解决了代码重复的问题，但是生成的实例跟原型还是没有联系，而且hashiqi和jinmao也没有联系，不能反映出他们是同一个原型对象的实例。 3、构造函数模式 用来创建对象的函数，叫做构造函数，其实就是一个普通函数，但是默认函数名首字母大写，对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。 function Dog(name, color) { this.name = name; this.color = color; } var hashiqi = new Dog('hashiqi', 'blackandwhite'); var jinmao = new Dog('jinmao', 'yellow'); console.log(hashiqi.name); //hashiqi console.log(jinmao.name); //jinmao hasiqi 和 jinmao有一个共同的构造函数 hashiqi.constructor === jinmao.constructor 是true 有以下几种方法可以验证原型对象与实例对象的关系： hashiqi instanceof Dog; // true Object.getPrototypeOf(hashiqi) === Dog.prototype // true Dog.prototype.isPrototypeOf(hashiqi) // true 缺点：构造函数解决了代码重复和实例与原型之间的联系，但是存在一个浪费内存的问题。比如远行对象有一些不变的属性和通用的方法，这样没生成一个实例，都必须为重复的东西多占一些内存。 扩展 我们可以尝试实现new运算符的逻辑如下： function New(func) { var obj = {}; //判断构造函数是否存在原型，如果有实例的__proto__属性就指向构造函数的prototype if(func.prototype !== undefined) { obj.__proto__ = func.prototype; } // 模拟出构造函数内部this指向实例的过程，注意，我们会拿到构造函数的返回值 var res = func.apply(obj, Array.from(arguments).slice(1)); // 正常构造函数是不需要显式声明返回值的，默认的返回值是生成的实例，但是一旦在构造函数中return 一个不是对象或者函数，就会改变构造函数的默认的返回值，其他的类型是不变的 if(typeof res === 'object' && res !== null || typeof res === 'function') { return res; } return obj; } var taidi = New(Dog, 'taidi', 'gray'); 注意：正常的构造函数是不需要自己写return 的，如果写了，当return的时候，如果是后面为简单类型，那么返回值还是构造函数生成的实例。如果return为对象类型或者函数，那么返回的就是return后面的这个对象或者函数。 4、prototype模式 每一个构造函数都有 prototype 属性，这个属性指向的是一个对象，这个对象的所有属性和方法，都会被构造函数的实例继承。基于这个属性，我们就可以有选择性的将一些通用的属性和方法定义到 prototype 上，每一个通过 new 生成的实例，都会有一个 __proto__ 属性指向构造函数的原型即 prototype ，这样我们定义到构造函数原型对象的属性和方法，就会被每一个实例访问到，从而变成公用的属性和方法。 function Dog(name, color) { this.name = name; this.color = color; } Dog.prototype.say = function () { console.log(\"汪汪\"); } var hashiqi = new Dog('hashiqi', 'blackandwhite'); var jinmao = new Dog('jinmao', 'yellow'); hashiqi.say(); // 汪汪 jinmao.say(); // 汪汪 console.log(hashiqi.say === jinmao.say); // true 注意：当实例对象和原型对象有相同的属性或者方法时，会优先访问实例对象的属性或方法。 面向对象的继承 1、构造函数内部的属性和方法继承 使用call或apply方法，将父对象的构造函数绑定在子对象上。 //父类 function Animal() { this.species = '动物'; } //子类 function Dog(name, color) { Animal.call(this); this.name = name; this.color = color; } var hashiqi = new Dog('hashiqi', 'blackandwhite'); console.log(hashiqi.species); //动物 2、prototype相关的继承 子类的prototype指向父类生成实例 function Animal() {}; Animal.prototype.species = '动物'; function Dog(name, color) { this.name = name; this.color = color; } Dog.prototype = new Animal(); //只要是prototype被完全覆盖，都得重写constructor。 Dog.prototype.constructor = Dog; var hashiqi = new Dog('hashiqi', 'blackandwhite'); 缺点： 每一次继承都得生成一个父类实例，比较占内存。 利用空对象作为中介 function Animal() {} Animal.prototype.species = '动物'; function Dog(name, color) { this.name = name; this.color = color; } //Middle生成的是空实例(除了__proto__)，几乎不占内存 function Middle() {} Middle.prototype = Animal.prototype; Dog.prototype = new Middle(); Dog.prototype.constructor = Dog; var hashiqi = new Dog('hashiqi', 'blackandwhite'); console.log(hashiqi.species); 几个月前在 CSDN 面试的时候，我说了这种继承方式，面试官就纠结这样修改子类的prototype不会影响父类么？是真的不会影响的，因为子类的prototype是指向Middle构造函数生成的实例，如果真的有心要改，得Dog.prototype.__proto__这么着来改。 Object.create() function Animal() {} Animal.prototype.species = '动物'; function Dog(name, color) { this.name = name; this.color = color; } Dog.prototype = Object.create(Animal.prototype,{ constructor: { value: Dog } }) var hashiqi = new Dog('hashiqi','blackandwhite'); console.log(hashiqi.species); //动物 3、拷贝继承 浅拷贝 function Animal() {} Animal.prototype.species = '动物'; function Dog(name, color) { this.name = name; this.color = color; } function extend(child, parent) { var c = child.prototype; var p = parent.prototype; for(key in p) { c[key] = p[key] } } extend(Dog, Animal); var hashiqi = new Dog('hashiqi', 'blackandwhite'); console.log(hashiqi.species) // 动物 深拷贝 function deepCopy(parent, child) { var child = child || {}; for(key in parent) { if(typeof parent[key] === 'object') { child[key] = parent[key].constructor === Array?[]:{}; deepCopy(parent[key],child[key]) } else { child[key] = parent[key]; } } return child; } ES6的面向对象 上面所说的是JavaScript语言的传统方法，通过构造函数，定义并生成新的对象。ES6中提供了更接近传统语言的写法，引入了Class(类)的概念，通过class关键字，可以定义类。 语法 ES6的类完全可以看成是构造函数的另外一种写法。 var method = 'say'; class Dog { constructor (name,color) { this.name = name; this.color = color; } //注意，两个属性之间跟对象不同，不要加逗号，并且类的属性名可以使用变量或者表达式，如下 [method] () { console.log('汪汪'); } } console.log(typeof Dog); // function 类的数据类型就是函数 console.log(Dog === Dog.prototype.constructor); // true 类本身就是构造函数 既然是构造函数，所以在使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 var hashiqi = new Dog('hashiqi', 'blackandwhite'); console.log(hashiqi.color); // blackandwhite //上面采用表达式声明的类的属性可以用一下两种方式调用 hashiqi[method](); // 汪汪 hashiqi.say(); // 汪汪 注意：1、先声明定义类，再创建实例，否则会报错class 不存在变量提升，这一点与ES5的构造函数完全不同 new Dog('hashiqi','blackandwhite') class Dog { constructor (name,color) { this.name = name; this.color = color; } } //Uncaught ReferenceError: Dog is not defined //上面代码，Dog类使用在前，定义在后，因为ES6不会把类的声明提升到代码头部，所以报错Dog没有定义。 2、必须使用new关键字来创建类的实例对象类的构造函数，不使用new是没法调用的，会报错。 这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 class Dog { constructor (name,color) { this.name = name; this.color = color; } } Dog(); // Uncaught TypeError: Class constructor Dog cannot be invoked without 'new' 3、定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。并且，方法之间不需要逗号分隔，加了会报错。 属性概念 constructor 构造函数 构造方法constructor是一个类必须要有的方法，默认返回实例对象；创建类的实例对象的时候，会调用此方法来初始化实例对象。如果你没有编写constructor方法，执行的时候也会被加上一个默认的空的constructor方法。 constructor方法是必须的，也是唯一的，一个类体不能含有多个constructor构造方法。 class Dog { constructor (name,color) { this.name = name; this.color = color; } //定义了两个constructor，所以会报错 constructor () { } } new Dog('hashiqi', 'blackandwhite') //Uncaught SyntaxError: A class may only have one constructor Class表达式 与函数一样，类可以使用表达式的形式定义。 const Hashiqi = class Dog { constructor (name,color) { this.name = name; this.color = color; } getName () { //此处的Dog就是Dog构造函数，在表达式形式中，只能在构造函数内部使用 console.log(Dog.name); } } var hashiqi = new Hashiqi('hashiqi', 'blackandwhite'); // 真正的类名是Hashiqi var jinmao = new Dog('jinmao', 'yellow'); // 会报错，Dog没有定义 通常我们的表达式会写成如下，省略掉类后面的名称 const Hashiqi = class { constructor (name,color) { this.name = name; this.color = color; } } var hashiqi = new Hashiqi('hashiqi', 'blackandwhite'); 实例方法和静态方法实例化后的对象才可以调用的方法叫做实例方法。直接使用类名即可访问的方法，称之为“静态方法” 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 class Dog { constructor (name,color) { this.name = name; this.color = color; } static say () { console.log('汪汪'); } } Dog.say(); //汪汪 静态方法和实例方法不同的是：静态方法的定义需要使用static关键字来标识，而实例方法不需要；此外，静态方法通过类名来的调用，而实例方法通过实例对象来调用。 类的继承 extends 类之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 class Dog extends Animal{} extends的继承目标extends关键字后面可以跟多种类型的值，有三种特殊情况 1、子类继承Object类 class A extends Object {} console.log(A.__proto__ === Object) //true console.log(A.prototype.__proto__ == Object.prototype) //true //这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 2、不存在继承 class A {} console.log(A.__proto__ === Function.prototype) // true console.log(A.prototype.__proto__ === Object.prototype) // true //这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。 //但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。 3、子类继承null class A extends null {} console.log(A.__proto__ === Function.prototype) //true console.log(A.prototype) //只有一个constructor属性，没有__proto__属性 这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。 但是，A调用后返回的对象不继承任何方法，所以没有__proto__这属性 super super这个关键字，既可以当作函数使用，也可以当作对象使用。 1、super作为函数调用时，代表父类的构造函数。作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 2、super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 class Animal { constructor (name) { this.name = name; this.species = '动物'; } say (){ return this.species; } } class Dog extends Animal{ constructor (name, color) { // 只要是自己在子类中定义constructor，必须调用super方法，否则新建实例会报错 //super作为函数调用，只能用在子类的constructor中 super(name); this.color = color; } getInfo () { //普通方法中，super指向父类的原型对象 console.log(super.say()+': '+this.name +','+this.color); } } var hashiqi = new Dog('hashiqi', 'blackandwhite'); hashiqi.getInfo() //动物：hashiqi,balckandwhite 注意：1、子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 2、在子类的普通方法中，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 3、使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 "},"JavaScript/ES6/block.html":{"url":"JavaScript/ES6/block.html","title":"由块级作用域引出的一场变革","keywords":"","body":"ES6走走看看—由块级作用域引出的一场变革 块级作用域又称词法作用域，存在于： 函数内部（函数作用域） 块中（字符 { 和 } 之间的区域） 注意：ES6允许块级作用域任意嵌套 {{{{{{let text = 'Hello World!'}}}}}} 因为有了块级作用域，然后我们才有继续往下聊的可能。 1、 块级声明 块级声明是用于声明在指定块的作用域之外无法访问的变量。 2、 let声明：用来声明一个块级作用域变量 声明的变量具有块级作用域的特性 // 例子 function getValue (condition) { if (condition) { let value = 'blue'; return value; } console.log(value) // 报错 value is not defined } getValue() 在同一个作用域内不能使用let声明同名的变量 // 不管是var,const或者let,新的let声明之前同名的变量，都会报错 var count = 30; let count = 40; // 报错 Identifier 'count' has already been declared // 函数形参和函数内部的let声明变量重名，报错 function test(value) { let value = 3; } test() // 报错 Identifier 'value' has already been declared // 在不同的作用域声明的变量重名是没问题的 let count = 30; if(true) { let count = 40; // 不同的作用域，不会报错 } 声明没有预解析，不存在变量提升，有“临时死区”(TDZ) 从块的开始到变量声明这段的区域被称为临时死区，ES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域，只要在声明之前就使用这些变量（赋值，引用等等），就会报错。 if(true) { console.log(typeof value); // 报错 value is not defined let value = 'blue'; } 注意：TDZ是区域是“块开始”到“变量声明”，下面的例子不报错 // typeof 说是相对安全，确实是，永远拿不到想要的结果 console.log(typeof value); // 打印 undefined，没有报错 if(true) { let value = 'red'; } 3、 const声明：声明常量（如PI），值一旦被设定后不可更改 常量声明的值是不可变的 注意：const声明的对象不允许修改绑定，但可以修改该对象的属性值。 const number = 6; number = 5; // 报错 Assignment to constant variable const obj = {number: 1}; obj.number = 2; // 不报错 obj = {number: 3}; // 报错 Assignment to constant variable 因为常量声明后值就不可更改了，所以声明时必须赋值 // 有效的常量 const count = 30; // 报错 Missing initializer in const declaration const name; 声明的常量具有块级作用域的特性 if(true) { const number = 5; } console.log(number) // 报错 number is not defined 在同一个作用域内不能使用const声明同名的变量 var message = 'Hello'; let age = 25; // 这两条语句都会报错 const message = 'Good'; const age = 30; 声明没有预解析，不存在变量提升，有“临时死区”(TDZ) 总结：一张表格 声明方式 变量提升 作用域 是否需要初始值 重复定义 var 是 函数级 不需要 允许 let 否 块级 不需要 不允许 const 否 块级 需要 不允许 扩展：再提一下变量命名，不管是var、let、const声明的变量名，可以由数字，字母，下划线及美元符号组成，但是不能以数字开头。美元符号可以放到任何一个位置，甚至单独一个美元符号。 4、 循环中的块作用域绑定 循环中的let声明 // 第一个对比 // before for(var i = 0; i {console.log(i)}) } funcs.forEach((ele) => { ele() }) // 打印 10次 10 // after var funcs = []; for(let i = 0; i {console.log(i)}) } funcs.forEach((ele) => { ele() }) // 打印 0 1 2 3 4 5 6 7 8 9 注意：有一点很重要，let 声明在循环内部的行为是标准中专门定义的，它不一定与 let 不提升特性有关。 循环中的const声明 // for 循环会报错 for (const i = 0; i 注意：const可以应用在 for-in 和 for-of 循环中，是因为每次迭代不会修改已有绑定，而是会创建一个新绑定。 5、 块级绑定最佳实践的进化 ES6 早期 普遍认为默认使用let来替代var,对于写保护的变量使用const ES6 使用中 普遍默认使用const，只有确实需要改变变量的值时使用let。因为大部分变量的值在初始化后不应再改变，而预料之外的变量值的改变是许多bug的源头。这样就可以在某种程度上实现代码的不可变，从而防止某些错误的发生。 6、 全局变量将逐步与顶层对象的属性脱钩 顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。 为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性； var a = 1; window.a // 1 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 上图可见let 声明的变量，并没有在Window对象里，而是一个新的Script对象。 扩展：如果需要在浏览器中跨frame或window访问代码，仍然可以用var在全局对象下定义变量。 7、 块级函数 从ECMAScript 6开始，在严格模式下，块里的函数作用域为这个块。ECMAScript 6之前不建议块级函数在严格模式下使用。 'use strict'; function f() { return 1; } { function f() { return 2; } } f() === 1; // true // f() === 2 在非严格模式下相等 注意：在非严格模式下不要用块级函数，因为在非严格模式下，块中函数的声明表现奇怪，有兼容性风险 if (shouldDefineZero) { function zero() { // DANGER: 兼容性风险 console.log(\"This is zero.\"); } } ECMAScript 6中，如果shouldDefineZero是false，则永远不会定义zero,因为这个块不执行。这是新标准定义的。然而，这里存在历史遗留问题，无论这个块是否执行，一些浏览器会定义zero。 在严格模式下，所有支持ECMAScript 6的浏览器以相同的方式处理：只有在shouldDefineZero为true的情况下定义zero，并且作用域只是这个块内。 "},"JavaScript/ES6/string.html":{"url":"JavaScript/ES6/string.html","title":"字符到底发生了什么变化","keywords":"","body":"ES6走走看看—字符到底发生了什么变化 1、 JavaScript字符编码的“坑”和“填坑” 计算机内部处理的信息，都是一个些二进制值，每一个二进制位（bit）有0和1两种状态。 一个字节（byte）有八个二进制位，也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。转换成十六进制，一个字节就是0x00到OxFF。 1.1 先来聊聊字符编码的历程 先祭出一张图，建议放大看 （1） ASCII 码 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码(美国信息交换标准代码)，一直沿用至今。 ASCII 码一共规定了128个字符的编码,只占用了一个字节的后面7位，最前面的一位统一规定为0。 第一部分：0～31（0x00~0x1F）及127(共33个)是控制字符或通信专用字符,有些可以显示在屏幕上,有些则不能显示,但能看到其效果(如换行、退格)如下表: 第二部分：是由20~7E共95个,这95个字符是用来表示阿拉伯数字、英文字母大小写和下划线、括号等符号,都可以显示在屏幕上如下表: (2) 非ASCII 编码 英语用128个符号编码就够了，但是世界上可不只有英语这一种语言，先不说汉语，就是那些不说英语的欧洲国家，128个符号是不够的。 一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号，这些欧洲国家使用的编码体系，可以表示最多256个符号。大家你加你的，我加我的。因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。 1981年IBM PC ROM256个字符的字符集，即IBM扩展字符集，这128个扩充字符是由IBM制定的,并非标准的ASCII码.这些字符是用来表示框线、音标和其它欧洲非英语系的字母。如下图： 在Windows 1.0（1985年11月发行）中，Microsoft没有完全放弃IBM扩展字符集，但它已退居第二重要位置。因为遵循了ANSI草案和ISO标准，纯Windows字符集被称作「ANSI字符集」。 由此可见扩展ASCII不再是国际标准。 而对于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右（《中华辞海》共收汉字87019个，日本《今昔文字镜》收录汉字超15万）。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312(中华人民共和国国家标准简体中文字符集)，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。其实GB 2312标准共收录6763个汉字，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。 (3) Unicode 之前的编码，大家在自己的国家使用都挺好的。世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号，所以一旦不同国家进行数据传输，结果就只有乱码了。 如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字所表示的，这是一种所有符号的编码。 Unicode，定义很简单，用一个码点(code point)映射一个字符。码点值的范围是从U+0000到U+10FFFF，可以表示超过110万个符号。 Unicode 最新版本的是 11.0，总共137,374个字符，这么看来，还是挺够用的。 Unicode最前面的65536个字符位，称为基本平面（BMP-—Basic Multilingual Plane），它的码点范围是从U+0000到U+FFFF。最常见的字符都放在这个平面，这是Unicode最先定义和公布的一个平面。 剩下的字符都放在补充平面（Supplementary Plane），码点范围从U+010000一直到U+10FFFF，共16个。 需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 // 例如下面的字符对应的码点 A的码点 U+0041 a的码点 U+0061 ©的码点 U+00A9 ☃的码点 U+2603 &#x1F4A9;的码点 U+1F4A9 正是因为上面说的，没有规定怎么存储，所以出现了Unicode 的多种存储方式，不同的实现导致了Unicode 在很长一段时间内无法推广，而且本来英文字母只用一个字节存储就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 在这个时候往往需要一个强大的外力推动，大家诉诸于利益，共同实现一个目标。所以，真正意义上的互联网普及了，地球变成了村子，交流越来越多，乱码是怎么能行。 (4) UTF-8、UTF-16、UTF-32 UTF（Unicode transformation format）Unicode转换格式，是服务于Unicode的，用于将一个Unicode码点转换为特定的字节序列。 上面三种都是 Unicode 的实现方式之一。 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过UTF-8 是在互联网上使用最广的一种 Unicode 的实现方式。 UTF-8 1992年开始设计，1993年首次被正式介绍，1996年UTF-8标准还没有正式落实前，微软的CAB（MS Cabinet）规格就明确容许在任何地方使用UTF-8编码系统。但有关的编码器实际上从来没有实现这方面的规格。2003年11月UTF-8被RFC 3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF，也就是说最多四个字节（之前可以使用一至六个字节为每个字符编码） UTF-8 是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同（也就是所说的兼容ASCII码）。在英文下这样就比UTF-16 和 UTF-32节省空间。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 UTF-16 基本平面的字符占用2个字节，辅助平面的字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。 这里涉及到一个怎么判断两个字节是一个字符，还是两个字节加两个字节组成的四个字节是一个字符？ 解决方法是：在基本平面内，从U+D800到U+DFFF是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 具体来说，辅助平面的字符位共有220个，也就是说，对应这些字符至少需要20个二进制位。UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF（空间大小210），称为高位（H），后10位映射在U+DC00到U+DFFF（空间大小210），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示(代理对的概念)。 所以，当我们遇到两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。 UTF-16编码介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。 UTF-32 UTF-32 最直观的编码方法，每个码点使用四个字节表示，字节内容一一对应码点。 UTF-32的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比ASCII编码大三倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5标准就明文规定，网页不得编码成UTF-32。 (5) UCS UCS-2 国际标准化组织（ISO）的ISO/IEC JTC1/SC2/WG2工作组是1984年成立的，想要做统一字符集，并与1989年开始着手构建UCS（通用字符集），也叫ISO 10646标准，当然另一个想做统一字符集的是1988年成立的Unicode团队，等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集（幸亏知道的早啊）。 1991年10月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是Unicode标准，并且修订此前发布的字符集，UCS的码点将与Unicode完全一致。（两个标准同时是存在） UCS的开发进度快于Unicode，1990年就公布了第一套编码方法UCS-2，使用2个字节表示已经有码点的字符。（那个时候只有一个平面，就是基本平面，所以2个字节就够用了。）UTF-16编码迟至1996年7月才公布，明确宣布是UCS-2的超集，即基本平面字符沿用UCS-2编码，辅助平面字符定义了4个字节的表示方法。 两者的关系简单说，就是UTF-16取代了UCS-2，或者说UCS-2整合进了UTF-16。所以，现在只有UTF-16，没有UCS-2。 UCS-2 使用2个字节表示已经有码点的字符,第一个字节在前，就是\"大尾方式\"（Big endian），第二个字节在前就是\"小尾方式\"（Little endian）。 那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？ Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做\"零宽度非换行空格\"（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。 如果一个文本文件的头两个字节是FE FF，就表示该文件采用大尾方式；如果头两个字节是FF FE，就表示该文件采用小尾方式。 1.2 JavaScript 编码方法存在的问题 最上面给出的图中字符的发展历史和JavaScript的诞生时间对比下，可以知道JavaScript如果要想用Unicode字符集，比较恰的选择是UCS-2编码方法，UTF-8,UTF-16都来的晚了一些，UCS-4倒是有的，但是英文字符本来一个字节就可以的，现在也要用4个字节，还是挺严重的事情的。96年那个时候，电脑普遍配置内存 8MB-16MB，硬盘850MB—1.2GB。 ECMAScript 6 之前，JavaScript字符编码方式使用UCS-2，是导致之后JavaScript对位于辅助平面的字符（超过两个字节的字符）操作出现异常情况的根本原因。 ECMAScript 6 强制使用UTF-16字符串编码来解决字符超过两个字节时出现异常的问题，并按照这种字符编码来标准化字符串操作。 // 存在的问题 const text = '&#x1F602;'; console.log(text.length) //打印 2 ，其实是一个Emoji表情符 console.log(/^.$/.test(text)) // false , 正则匹配也出了问题，说不是一个字符 console.log(/^..$/.test(text)) // true , 是两个字符 console.log(text.charAt(0)) // � 前后两个字节码位都是落在U+D800到U+DFFF这个空段，打印不出东西 console.log(text.charAt(1)) // � console.log(text.charCodeAt(0)) // 55357 转成十六进制 0xd83d console.log(text.charCodeAt(1) //56834 转成十六进制 0xde02 // 经过查询Unicode的字符表，&#x1F602;的码位是U+1f602 console.log('\\u1f602' === '&#x1F602;') //false console.log('\\ud83d\\ude02' === '&#x1F602;') // true 扩展：� 的Unicode码点是 U+FFFD，通常用来表示Unicode转换时无法识别的字符（也就是乱码） 1.3 ECMAScript 6 解决字符编码的问题 (1) 为解决charCodeAt()方法获取字符码位错误的问题，新增codePointAt()方法 codePointAt()方法完全支持UTF-16,参数接收的是编码单元的位置而非字符位置，返回与字符串中给定位置对应的码位，即一个整数。 对于BMP字符集中的字符，codePointAt()方法的返回值跟charCodeAt()相同，而对于非BMP字符集来说，返回值不同。 const text = '&#x1F602;'; console.log(text.charCodeAt(0)) // 位置0处的一个编码单元 55357 console.log(text.charCodeAt(1)) // 位置1处的一个编码单元 56834 console.log(text.codePointAt(0)) // 位置0处的编码单元开始的码位，此例是从这个编码单位开始的两个编码单元组合的字符（四个字节），所以会打印出所有码位，即四字节的码位 128514 即0x1f602，大于0xffff，也证明了是占四个字节的存储空间。 console.log(text.codePointAt(1)) // 位置1处的编码单元开始的码位 56834 (2) 为解决超过两个字节的码点与字符转换问题，新增了fromCodePoint()方法 // 打印&#x1F602; console.log(String.fromCharCode(128514)) // 打印失败  console.log(String.fromCharCode(55357,56834)) // 参数可以接收一组序列数字，表示 Unicode 值。打印成功 &#x1F602; console.log(String.fromCodePoint(128514)) // 打印成功 &#x1F602; console.log(String.fromCodePoint(0x1f602)) // 可以接收不同进制的参数，打印成功 &#x1F602; (3) 为解决正则表达式无法正确匹配超过两个字节的字符问题，ES6定义了一个支持Unicode的 u 修饰符 const text = '&#x1F602;'; console.log(/^.$/.test(text)) // false , 正则匹配出了问题，说不是一个字符 console.log(/^..$/.test(text)) // true , 是两个字符 console.log(/^.$/u.test(text)) // true， 加入 u 修饰符，匹配正确 注意：u修饰符是语法层面的变更，在不支持ES6的JavaScript的引擎中使用它会导致语法错误，可以使用RegExp构造函数和try……catch来检测，避免发生语法错误 (4) 为解决超过\\uffff码点的字符无法直接用码点表示的问题，引入了\\u{xxxxx} console.log('\\u1f602' === '&#x1F602;') //false console.log('\\ud83d\\ude02' === '&#x1F602;') // true console.log('\\u{1f602}' === '&#x1F602;') // true (5) 解决字符串中有四个字节的字符的length问题 const text = '笑哭了&#x1F602;'; // 解决一 // 上线UTF-16如果是在辅助平面（占4个字节）的话，会有代理对，U+D800-U+DBFF和U+DC00-U+DFFF var surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g; // 匹配UTF-16的代理对 function firstGetRealLength(string) { return string // 把代理对改为一个BMP的字符,然后获取长度 .replace(surrogatePair, '_') .length; } firstGetRealLength(text); // 4 // 解决二（推荐） // 字符串是可迭代的，可以用Array.from()来转化成数组计算length function secondGetRealLength(string) { return Array.from(string).length; } secondGetRealLength(text); // 4 // 解决三 // 使用正则新增加的修饰符u function thirdGetRealLength(string) { let result = text.match(/[\\s\\S]/gu); return result?result.length:0; } thirdGetRealLength(text); // 4 (5) 解决字符串中有四个字节的字符的字符串反转问题 const text = '笑哭了&#x1F602;'; function reverse(string) { return string.split('').reverse().join(''); } function reversePlus(string) { return Array.from(string).reverse().join(''); } console.log(reverse(text)) // ��了哭笑 因为&#x1F602;是\\ud83d\\ude02反转后是\\ude02\\ud83d,不是一个合法的代理对（高低字节范围不同） console.log(reversePlus(text)) // &#x1F602;了哭笑 2、 ECMAScript 6 模板字面量 模板字面量的填补的ES5的一些特性 多行字符串 基本的字符串格式化,有将变量的值嵌入字符串的能力 HTML转义，向HTML中插入经过安全转换后的字符串的能力 (1)多行字符串中反撇号中的所有空白符都属于字符串的一部分 let message = `a b`; console.log(message.length) //15 (2)标签模板：模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 let a = 5; let b = 10; function tag(s, v1, v2) { console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return \"OK\"; } // 标签模板调用 tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag(['Hello ', ' world ', ''], 15, 50); //打印 // \"Hello \" // \" world \" // \"\" // 15 // 50 // \"OK\" “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。标签模板的另一个应用，就是多语言转换（国际化处理）。 参考链接 字符编码笔记：ASCII，Unicode 和 UTF-8 谈谈Unicode编码——其中有“大尾”和“小尾”的来源描述小人国呦 字符编码趣闻 Javascript有个Unicode的天坑 Unicode与JavaScript详解 UTF-8, a transformation format of ISO 10646 ASCII UTF-8 UTF-8 遍地开花 UTF-16 通用字符集 Unicode官网 Javascript诞生记 "},"JavaScript/typescript/intro.html":{"url":"JavaScript/typescript/intro.html","title":"介绍","keywords":"","body":"介绍 类型检查 静态类型语言在编译时执行类型检查，而动态类型的语言在运行时执行类型检查。类型检查确保并强制你声明的变量的类型（常量，布尔值，数字，变量，数组，对象）与您指定的值相匹配。 当类型错误发生时，静态类型检查和动态类型检查之间的差异最为重要。在静态类型语言中，错误发生在编译步骤中，即在编译时会出现类型错误。在动态类型语言中，只有执行程序后才会出现错误。错误发生在运行时。 静态类型优势 可以尽早发现BUG和错误静态类型检查允许我们在程序没有运行之前就可以确定我们所设定的确定性是否是对的。一旦有违反这些既定规则的行为，它能在运行之前就发现，而不是在运行时。 起到在线文档的功能 减少了复杂的错误处理 使你在重构时更有信心更新了方法，并且相应地更新了类型定义，那么类型检查器将会帮我去捕获我遗漏的错误。 将数据和行为分离 帮助我们消除了一整类bug 减少单元测试的数量 使用场景 这段程序对你的业务非常关键 随着需求的变化，这段程序很可能会被重构 这段程序很复杂并且有许多活动组件 这段程序有一个大团队的开发者维护，他们需要能够快速且准确地理解代码 TypeScript TypeScript 是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。 TypeScript 同样支持最新的 ECMAScript 标准，并能将代码根据需求转换为 ES 3 / 5 / 6，这也就意味着，开发者随时可以使用最新的 ECMAScript 特性，比如 module / class / spread operator 等，而无需考虑兼容性的问题。ECMAScript 所支持的类型机制非常丰富，包括：interface、enum、hybird type 等等。 目前主流的 IDE 都为 TypeScript 的开发提供了良好的支持，比如 Visual Studio / VS Code、Atom、Sublime 和 WebStorm。TypeScript 与 IDE 的融合，便于开发者实时获取类型信息。 推荐资料 为什么要在javascript中进行静态类型检查-静态类型的优点和缺点 "},"JavaScript/typescript/synax.html":{"url":"JavaScript/typescript/synax.html","title":"基本语法","keywords":"","body":"语法 // 原始值 const isDone: boolean = false; const amount: number = 6; const address: string = 'beijing'; const greeting: string = `Hello World`; // 数组 const list: number[] = [1, 2, 3]; const list: Array = [1, 2, 3]; // 元组 const name: [string, string] = ['Sean', 'Sun']; // 枚举 enum Color { Red, Green, Blue }; const c: Color = Color.Green; // 任意值：可以调用任意方法 let anyTypes: any = 4; anyTypes = 'any'; anyTypes = false; // 空值 function doSomething (): void { return undefined; } // 类型断言 let someValue: any = \"this is a string\"; let strLength: number = (someValue as string).length; TypeScript 中的 Interface 可以看做是一个集合，这个集合是对对象、类等内部结构的约定 // 定义接口 Coords // 该接口包含 number 类型的 x，string 类型的 y // 其中 y 是可选类型，即是否包含该属性无所谓 interface Coords { x: number; y?: string; }; // 定义函数 where // 该函数接受一个 Coords 类型的参数 l function where (l: Coords) { // doSomething } const a = { x: 100 }; const b = { x: 100, y1: 'abc' }; // a 拥有 number 类型的 x，可以传递给 where where(a); // b 拥有 number 类型的 x 和 string 类型的 y1，可以传递给 where where(b); // 下面这种调用方式将会报错，虽然它和 where(b) 看起来是一致的 // 区别在于这里传递的是一个对象字面量 // 对象字面量会被特殊对待并经过额外的属性检查 // 如果对象字面量中存在目标类型中未声明的属性，则抛出错误 where({ x: 100, y1: 'abc' }); // 最好的解决方式是为接口添加索引签名 // 添加如下所示的索引签名后，对象字面量可以有任意数量的属性 // 只要属性不是 x 和 y，其他属性可以是 any 类型 interface Coords { x: number; y?: string; [propName: string]: any }; 接口还常用于约束函数的行为 // CheckType 包含一个调用签名 // 该调用签名声明了 getType 函数需要接收一个 any 类型的参数，并最终返回一个 string 类型的结果 interface CheckType { (data: any): string; }; const getType: CheckType = (data: any) : string => { return Object.prototype.toString.call(data); } getType('abc'); // => '[object String]' Interface 也可以用于约束类的行为 interface ClockConstructor { new (hour: number, minute: number): ClockInterface; } interface ClockInterface { tick(); } function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface { return new ctor(hour, minute); } class DigitalClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(\"beep beep\"); } } class AnalogClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(\"tick tock\"); } } let digital = createClock(DigitalClock, 12, 17); let analog = createClock(AnalogClock, 7, 32); 除了 ES6 增加的 Class 用法，TypeScript 还增加了 C++、Java 中常见的 public / protected / private 限定符，限定变量或函数的使用范围。 TypeScript 使用的是结构性类型系统，只要两种类型的成员类型相同，则认为这两种类型是兼容和一致的，但比较包含 private 和 protected 成员的类型时，只有他们是来自同一处的统一类型成员时才会被认为是兼容的 class Animal { private name: string; constructor(theName: string) { this.name = theName; } } class Rhino extends Animal { constructor() { super(\"Rhino\"); } } class Employee { private name: string; constructor(theName: string) { this.name = theName; } } let animal = new Animal(\"Goat\"); let rhino = new Rhino(); let employee = new Employee(\"Bob\"); animal = rhino; // Error: Animal and Employee are not compatible animal = employee; function "},"mobile/fit.html":{"url":"mobile/fit.html","title":"移动端适配","keywords":"","body":"移动端适配 基础概念 PX(CSS pixels)虚拟像素，可以理解为“直觉”像素，CSS和JS使用的抽象单位，浏览器内的一切长度都是以CSS像素为单位的，CSS像素的单位是px。在CSS规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px是一个相对单位，相对的是物理像素(device pixel)。px实际是pixel（像素）的缩写，它是图像显示的基本单元，既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念。所以在谈论像素时一定要清楚它的上下文！ 屏幕尺寸屏幕大小的物理尺寸，屏幕对角线长度衡量。单位：英寸，1英寸 = 2.54厘米 像素密度(PPI)像素密度(Pixels Per Inch)，所表示的是每英寸所拥有的像素数量。因此PPI数值越高，即代表显示屏能够以越高的密度显示图像。 物理像素(physical pixel或device pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel或device independent pixel)设备独立像素(也叫密度无关像素、逻辑像素)，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。 设备像素比(device pixel ratio)设备像素比(简称dpr)定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到： 设备像素比 = 物理像素 / 设备独立像素 // 在某一方向上，x方向或者y方向 在javascript中，可以通过window.devicePixelRatio获取到当前设备的dpr。在css中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 以iphone6为例 设备宽高为375×667，可以理解为设备独立像素(或css像素)。dpr为2，根据上面的计算公式，其物理像素就应该×2，为750×1334。 如上图，对于这样的css样式width: 2px; height: 2px;在不同的屏幕上(普通屏幕 vs retina屏幕)，css像素所呈现的大小(物理尺寸)是一致的，不同的是1个css像素所对应的物理像素个数是不一致的。在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。 位图像素一个位图像素是栅格图像(如：png, jpg, gif等)最小的数据单元。每一个位图像素都包含着一些自身的显示信息(如：显示位置，颜色值，透明度等)。 问题一： retina下图片的展示情况？ 理论上，1个位图像素对应于1个物理像素，图片才能得到完美清晰的展示。在普通屏幕下是没有问题的，但是在retina屏幕下就会出现位图像素点不够，从而导致图片模糊的情况。 如上图：对于dpr=2的retina屏幕而言，1个位图像素对应于4个物理像素，由于单个位图像素不可以再进一步分割，所以只能就近取色，从而导致图片模糊(注意上述的几个颜色值)。所以，对于图片高清问题，比较好的方案就是两倍图片(@2x)。 如：200×300(css pixel)img标签，就需要提供400×600的图片。 如此一来，位图像素点个数就是原来的4倍，在retina屏幕下，位图像素点个数就可以跟物理像素点个数形成 1 : 1的比例，图片自然就清晰了。 问题二：普通屏幕下，也用了两倍图片，会怎样呢？ 在普通屏幕下，200×300(css pixel)img标签，所对应的物理像素个数就是200×300个，而两倍图片的位图像素个数则是200×300*4，所以就出现一个物理像素点对应4个位图像素点，所以它的取色也只能通过一定的算法(显示结果就是一张只有原图像素总数四分之一，我们称这个过程叫做downsampling)，肉眼看上去虽然图片不会模糊，但是会觉得图片缺少一些锐利度，或者是有点色差(但还是可以接受的)。如下图展示： 三个viewport layout viewportlayout viewport的宽度可以通过document.documentElement.clientWidth 来获取。（DOM的宽度）layout viewport 的宽度是大于浏览器可视区域的宽度的移动设备默认的viewport是layout viewport visual viewport代表浏览器可视区域的大小，在移动端可以描述为屏幕宽度。visual viewport的宽度可以通过window.innerWidth 来获取。 ideal viewport移动设备的理想viewport，ideal viewport的宽度等于移动设备的屏幕宽度，作用是使布局视口就是可见视口。 多屏适配布局问题 移动端布局，为了适配各种大屏手机，目前最好用的方案莫过于使用相对单位rem。rem的应用其本质就是等比缩放，就是屏幕分成多少个rem份，然后每一份大小就会根据根节点html的font-size大小动态改变。基于rem的原理，我们要做的就是: 针对不同手机屏幕尺寸和dpr动态的改变根节点html的font-size大小(基准值)。 font-size = document.documentElement.clientWidth * dpr / 10; 说明：乘以dpr，是因为页面有可能为了实现1px border页面会缩放(scale) 1/dpr 倍(如果没有，dpr=1)除以10，是为了取整，方便计算(理论上可以是任何值)，这里的10就表示有10rem份所以就像下面这样，html的font-size可能会：iphone3gs: 320px / 10 = 32pxiphone4/5: 320px 2 / 10 = 64pxiphone6: 375px 2 / 10 = 75px 方案一： 缺点：要加载一段js代码优点：可以精确地算出不同屏幕所应有的rem基准值，解决了1）border: 1px问题 2）图片高清问题 3）屏幕适配布局问题 方案二搭配vw和rem // rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推 $vw_fontsize: 75; // iPhone 6尺寸的根元素大小基准值 @function rem($px) { @return ($px / $vw_fontsize ) * 1rem; } // 根元素大小使用 vw 单位 $vw_design: 750; html { font-size: ($vw_fontsize / ($vw_design / 2)) * 100vw; // 同时，通过Media Queries 限制根元素最大最小值 @media screen and (max-width: 320px) { font-size: 64px; } @media screen and (min-width: 540px) { font-size: 108px; } } // body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小 body { max-width: 540px; min-width: 320px; } 推荐资源 移动端高清、多屏适配方案（上） 移动端高清、多屏适配方案（下） CSS像素、物理像素、逻辑像素、设备像素比、PPI、Viewport "},"node/":{"url":"node/","title":"基础介绍","keywords":"","body":"Node基础简介 node环境下的相关操作 - 具体可参考 REPL 模块 .help - 列出使用命令 .break - 退出多行表达式 .clear – 1、退出多行表达式 2、清除REPL运行环境的上下文对象中保存的所有变量和函数 .exit – 退出REPL运行环境 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容 ctrl + c：.break ctrl + c (两次)：.exit ctrl + d：.exit 向上/向下 键 - 查看输入的历史命令 tab 键 - 查看当前作用域下的所有可用的方法 REPL(交互式解释器)R Read - 读取E Eval - 运算P Print - 打印输出L Loop - 重复在REPL运行环境中使用下划线字符（“_”）来访问最近使用的表达式，但是不意味着可以改变变量的值 模块系统 作用：为了更好组织、管理代码，nodejs引入了模块 定义：一个文件就是一个独立的模块 特点：每个模块都有自己的独立作用域 - 模块作用域 扩展：作用域 全局作用域 函数作用域 块级作用域（es2015+） 模块作用域 Node.js核心模块 全局对象 全局对象global，其最根本的作用是作为一个全局变量的宿主。按照ECMAScript定义，满足以下条件的变量是全局变量： 在最外层定义的变量 全局对象的属性 隐式定义的变量（未定义直接赋值的变量） 在Node.js中你不可能在最外层定义变量，因为所有用户代码都是输入当前模块的，而模块本身不是最外层上下文。 process: 用于描述当前Node.js进程状态的对象，提供了一个与操作系统的简单接口。 process.argvprocess.argv 属性返回一个数组，这个数组包含了启动Node.js进程时的命令行参数。第一个元素为process.execPath。即Node.js进程的可执行文件所在的绝对路径第二个元素为当前执行的JavaScript文件路径。剩余的元素为其他命令行参数。 ``` node index.js 1991 name=chenfangxu --v \"lalla\" [ '/usr/local/Cellar/node/7.9.0/bin/node', '/Users/cfangxu/project/demo/myNEapp/site/index.js', '1991', 'name=chenfangxu', '--v', 'lalla' ] * process.env：返回一个对象，成员为当前Shell的环境变量，比如process.env.HOME返回用户的主目录。 * process.platform：返回一个字符串，表示当前的操作系统，比如Linux。 #### 方法 * process.nextTick(callback) 为事件循环设置一项任务，Node.js会在下次事件循环中调用callback（具体的时间点是：在当前执行栈的尾部、下一次Event Loop之前执行）。因为一个Node.js进程只有一个线程，因此在任何时刻都只有一个事件在执行。如果这个事件占用了大量的CPU时间，执行事件循环中的下一个事件就需要等待很久，因此Node.js的一个编程原则就是尽量缩短每个事件的执行时间。process.nextTick（）提供了一个这样的工具，可以把很复杂的工作拆散，编程一个个较小的事件。 * process.chdir()：切换工作目录到指定目录。 * process.cwd()：返回运行当前脚本的工作目录的路径。 * process.exit([code])：退出当前进程。如果code未提供，此exit方法要么使用'success' 状态码 0，要么使用process.exitCode属性值，前提是此属性已被设置。 Node.js在所有['exit']事件监听器都被调用了以后，才会终止进程。 > console:用于提供控制台标准输出 * console.log():向标准输出流打印字符并以换行符结束。 * console.error():向标准错误流输出 * console.trace(): 向标准错误流输出当前的调用栈 #### 重点说一下字符串替换(浏览器和Node.js有些不一样) 在字符串中使用占位符，并且用传递给该方法的其他参数替换占位符，从而完成字符串的替换。 1. %s | 用字符串替换元素 2. %(d|i)| 用整数替换元素 3. %f | 用浮点数替换元素,使用%.1f可以将浮点数格式化为小数点后只保留一位有效数字。也可以使用 %.nf来指定小数点后保留n位数字。 4. %(o|O) | 元素作为一个对象来显示 5. %c | 应用提供的 CSS * console.assert(value[, message][, ...args]) 一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。 如果提供了 message，则使用 util.format() 格式化并作为错误信息使用。 *注意*:Node.js 中的 console.assert() 方法与在浏览器中的 console.assert() 方法的实现是不一样的。 具体地说，在浏览器中，用非真的断言调用 console.assert() 会导致 message 被打印到控制台但不会中断后续代码的执行。 而在 Node.js 中，非真的断言会导致抛出 AssertionError。 ### util实用模块 提供常用函数的集合，用于弥补核心JavaScript的功能过于精简不足。 * util.format(format[, ...args]) util.format() 方法返回一个格式化后的字符串，使用第一个参数作为一个类似 printf 的格式。 第一个参数是一个字符串，包含零个或多个占位符。 每个占位符会被对应参数转换后的值所替换。 支持的占位符有： * %s - 字符串。 * %d - 数值（整数或浮点数）。 * %i - 整数。 * %f - 浮点数 * %j - JSON。如果参数包含循环引用，则用字符串 '[Circular]' 替换。 * %o - 一个对象的字符串，类似用util.inspect() 并且options { showHidden: true, depth: 4, showProxy: true }， 展示整个对象包括不可遍历的和symbol属性 * %O - 一个对象的字符串 类似用util.inspect() 并且options为空 展示整个对象不包括不可遍历的和symbol属性 * %% - 单个百分号（'%'）。不消耗参数。 *注意*: 只有一个参数，不会格式化，而是直接返回字符串。 util.format('%% %s'); // '%% %s' ``` util.inspect(object[, options]) options showHidden 如果为 true，则 object 的不可枚举的符号与属性也会被包括在格式化后的结果中。 默认为 false。 depth 指定格式化 object 时递归的次数。 这对查看大型复杂对象很有用。 默认为 2。 若要无限地递归则传入 null。 colors 如果为 true，则输出样式使用 ANSI 颜色代码。 默认为 false。 颜色可自定义。 customInspect 如果为 false，则 object 上自定义的 inspect(depth, opts) 函数不会被调用。 默认为 true。 showProxy 如果为 true，则 Proxy 对象的对象和函数会展示它们的 target 和 handler 对象。 默认为 false。 maxArrayLength 指定格式化时数组和 TypedArray 元素能包含的最大数量。 默认为 100。 设为 null 则显示全部数组元素。 设为 0 或负数则不显式数组元素。 breakLength 一个对象的键被拆分成多行的长度。 设为 Infinity 则格式化一个对象为单行。 默认为 60。 文件系统fs fs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等POSIX文件系统的操作。与其他模块不同，fs模块中大部分的操作都提供了异步的和同步的两个版本。 注意： Node.js的异步编程接口习惯是以函数的最后一个参数为回调函数，通常一个函数只有一个回调函数。回调函数的实际参数中第一个是err，其余的参数是其他返回的内容。如果没有发生错误，err的值会是null或undefined,如果有错误发生，err通常是Error对象的实例。 注意： 与同步I/O函数不同，Node.js中的异步函数大多没有返回值。 fs.open方法中有参数mode，用于创建文件时给文件指定权限，默认为0o666。回调函数将会传递一个文件描述符fd。文件权限： 是POSIX操作系统中对文件读取和访问权限的规范，通常用一个八进制数来表示。例如0o754表示文件所有者的权限是7（读、写、执行），同组的用户权限是5（读，执行），其他用户的权限是4（读），写成字符表示就是 -rwxr-xr--。文件描述符： 是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引。 module 可跳转JavaScript的模块#Node.js模块查看 "},"network-basics/HTTP/":{"url":"network-basics/HTTP/","title":"介绍","keywords":"","body":"简介 概念 http是一种无状态的协议，只有请求才会响应，然后断开，也没有记忆。互联网中的设备要完成通信必须基于双方都能识别的规则，如通信的语音，格式，硬件和操作系统等等，这些规则的集合统称为TCP/IP 协议族。 URL（Uniform Resource Locator，统一资源定位符）是URI（统一资源标识符）的子集，URI可以标识网络中的任意资源，有了URI才能在海量的网络资源中找到我们需要的那部分。 DNS（Domain Name System， 域名系统），因为IP地址的记忆实在是反人类，而域名机器识别不了，所以有了DNS将二者自由转换。 ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就，可以反查出对应的 MAC 地址。除了路由器外，信息要到达目标服务器地址可能还要经过代理服务器，网关等设备 HTTP报文详解 用于HTTP协议交互的信息被称为HTTP报文。 Cache-Control： 操作缓存的指令。主要有以下几种用法 Cache-Control: no-cache表示客户端不接受缓存的响应，必须请求最新的资源。Cache-Control: no-store表示客户端不能缓存请求或者响应的任意一部分。Cache-Control: max-age=604800（单位 ：秒）max-age 数值代表资源保存为缓存的最长时间。当指定 max-age 值为0或者缓存超过最大时间，那么缓存服务器通常需要将请求转发给 源服务器。 Connection： 由于HTTP1.1后，客户端和服务端建立连接后可以多次通信，连接的是否中断可以依靠以下指令控制。 Connection: close表示想断开当前连接。Connection: Keep-Alive表示想保持当前连接。 Date： 表明创建HTTP报文的日期和时间 Upgrade： 用于检测 HTTP 协议及其他协议是否可使用更高 的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。 比如Upgrade: websocket Via: 为了追踪客户端与服务器之间的请求和响应报文的传输路径。之前说过，一个请求的过程除了经过路由器外，还可能经过代理，网关等设备，这些设备的路径将被记录。 Warning: 一些警告信息。 Accept: 用户代理能够处理的媒体类型和优先级。 Accept: text/html,image/jpeg客户端可以处理的媒体类型，包括文本和jpeg格式的图片 Accept-Charset: 用户代理支持的字符集 及字符集的相对优先顺序。 Accept-Charset: iso-8859-5, unicode-1-1;q=0.8权重 q 值来表示相对优先级。 Accept-Encoding: 用户代理支持的内容编码及内容编码的优先级顺序。 Accept-Encoding: gzip, deflate,compress Accept-Language: 用户代理能够处理的自然语言集（指中文或英文等）及优先级。 Accept-Language: zh-cn Authorization: 用户代理的认证信息。 Host: 请求的资源所处的互联网主机名和端口号。 Range: Range: bytes=5001-10000 请求获取从第 5001 字节至第 10000 字节的资源 Referer: 请求的URI是哪个页面发起的。 Referer: http://www.xxx.com/index.html User-Agent: 创建请求的浏览器或用户代理名称等信息 Age: 源服务器在多久前创建了响应。字段值的单位为秒。 Age: 600 Expires: 资源失效的日期。 Last-Modified: 说明资源最终修改的时间。 Allow： 支持 Request-URI 指定资源的所有 HTTP 方法。Allow: GET, HEAD Content-Type: 实体主体内对象的媒体类型。 Content-Type: text/html; charset=UTF-8 Content-Encoding: 服务器对实体的主体部分选用的内容编码方式。 Content-Encoding: gzip Content-Language: 实体主体使用的自然语言（指中文或英文等语言） Content-Length: 表明了实体主体部分的大小（单位是字节） Content-Length: 15000当我们获取下载进度信息时，常常使用使用这个信息。 Set-Cookie 和cookie相关的信息。 安全相关的2个属性 Cookie: 如果想HTTP状态管理时，请求的首部加入 Cookie: status=enableHTTP是无状态的，其状态管理要依赖于Cookie。 状态码 "},"network-basics/request/":{"url":"network-basics/request/","title":"网络请求","keywords":"","body":"网络请求 URL的组成 以 http://www.bing.com/search?q=gulp&first=9#history 为例： 协议 主机名 端口 路径 查询字符串 信息片段 http:// www.bing.com :80(默认端口) /search ?q=gulp&first=9 #history 概念 协议： 协议确定如何传输请求，主要是 http 和 https ，其他的还有 file 和 ftp 。 主机名： 主机名标识服务器。 端口： 每一台服务器都有一系列的端口号。一些端口号比较特殊，如 80 和 443 端口。如果省略端口值，那么默认 80 端口负责HTTP传输，443 端口负责HTTPS传输。 路径： URL中影响应用程序的第一个组成部分通常是路径，路径是应用中的页面或其他资源的唯一标识。 查询字符串： 查询字符串是一种键值对集合，是可选的。它以问号(?)开头，键值对则以与号(&)分隔开。所有的名称和值都必须是URL编码的。 信息片段： 信息片段（或散列）被严格限制在浏览器中使用，不会传递到服务器。用它控制单页应用或AJAX富应用越来越普遍。最初，信息片段只是用来让浏览器展现文档中通过锚点标记()指定的部分。 "},"assistive-tools/git/intro.html":{"url":"assistive-tools/git/intro.html","title":"版本控制系统简介","keywords":"","body":"版本控制系统简介 版本控制系统是能够随着时间的推进记录一系列文件的变化以便于你以后想要的退回到某个版本的系统。 版本控制系统分为三大类： 本地版本控制（Local Version Control Systems） 是将文件的各个版本以一定的数据格式存储在本地的磁盘（有的VCS 是保存文件的变化补丁，即在文件内容变化时计算出差量保存起来，通过应用所有的补丁，可以重新计算出各个版本的文件内容），这种方式在一定程度上解决了手动复制粘贴的问题，但无法解决多人协作的问题。 集中式版本控制（Centralized Version Control Systems） 相比本地版本控制没有什么本质的变化，只是多了个一个中央服务器，各个版本的数据库存储在中央服务器，管理员可以控制开发人员的权限，而开发人员也可以从中央服务器拉取数据。集中式版本控制虽然解决了团队协作问题，但缺点也很明显：所有数据存储在中央服务器，服务器一旦宕机或者磁盘损坏，会造成不可估量的损失。 分布式版本控制（ Distributed Version Control System） 与前两者均不同。 首先，在分布式版本控制系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，系统保存的的不是文件变化的差量，而是文件的快照，即把文件的整体复制下来保存，而不关心具体的变化内容。其次，最重要的是分布式版本控制系统是分布式的，当你从中央服务器拷贝下来代码时，你拷贝的是一个完整的版本库，包括历史纪录，提交记录等，这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 推荐资料 Git的核心概念 GitHub超详细图文攻略 - Git客户端下载安装 GitHub提交修改源码工作流程 Pro Git（中文版） 一本关于github的书-GotGitHub "},"assistive-tools/git/workflow.html":{"url":"assistive-tools/git/workflow.html","title":"安装和入门","keywords":"","body":"安装和入门 基础配置和入门操作 安装 Git客户端下载地址: 点击跳转 安装步骤略过欢迎页面、接受协议和选择安装目录步骤，从选择安装组件开始。 选择安装组件 : 可以默认选择; 图标组件(Addition icons) : 选择是否创建快速启动栏图标 或者 是否创建桌面快捷方式; 桌面浏览(Windows Explorer integration) : 浏览源码的方法, 单独的上下文浏览 只使用bash 或者 只用Git GUI工具; 高级的上下文浏览方法 使用git-cheetah plugin插件; 关联配置文件 : 是否关联git配置文件, 该配置文件主要显示文本编辑器的样式; 关联shell脚本文件 : 是否关联Bash命令行执行的脚本文件; 使用TrueType编码 : 在命令行中是否使用TruthType编码, 该编码是微软和苹果公司制定的通用编码; 开始菜单快捷方式目录 : 设置开始菜单中快捷方式的目录名称, 也可以选择不在开始菜单中创建快捷方式; 设置环境变量 : 选择使用什么样的命令行工具, 一般情况下我们默认使用Git Bash即可, 默认选择; Git自带 : 使用Git自带的Git Bash命令行工具; 系统自带CMD : 使用Windows系统的命令行工具; 二者都有 : 上面二者同时配置, 但是注意, 这样会将windows中的find.exe 和 sort.exe工具覆盖, 如果不懂这些尽量不要选择; 选择换行格式 : 检查出windows格式转换为unix格式 : 将windows格式的换行转为unix格式的换行在进行提交; 检查出原来格式转为unix格式 : 不管什么格式的, 一律转为unix格式的换行在进行提交; 不进行格式转换 : 不进行转换, 检查出什么, 就提交什么; 之后就是正常安装了。 配置GitHub 首先需要检查你电脑是否已经有 SSH key 运行 git Bash 客户端，输入如下代码： $ cd ~/.ssh $ ls 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3。 创建本地ssh 在命令行工具里使用：ssh-keygen -t rsa -C \"xxxxx@163.com\" 代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。GitHub邮箱 : 该命令后面的邮箱就是GitHub的注册邮箱以上代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如： Generating public/private rsa key pair. # Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 当然，你也可以不输入文件名，使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码），当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了，如：Enter passphrase (empty for no passphrase): # Enter same passphrase again: 接下来，就会显示如下代码提示，如：Your identification has been saved in /c/Users/you/.ssh/id_rsa. # Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. # The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db xxxx@163.com 当你看到上面这段代码的时候，那就说明，你的 SSH key 已经创建成功，你只需要添加到github的SSH key上就可以了。 将ssh配置到GitHub中 进入生成的ssh目录（默认） : C:\\Users\\Administrator\\.ssh 中, 使用记事本打开 id_rsa.pub 文件, 将该文件中的内容复制。或者git命令复制该文件的内容 $ clip 登录你的github账号，从右上角的设置（ Account Settings ）进入，然后点击菜单栏的 SSH key 进入页面添加 SSH key。 点击 Add SSH key 按钮添加一个 SSH key 。把你复制的 SSH key 代码粘贴到 key 所对应的输入框中，记得 SSH key 代码的前后不要留有空格或者回车。当然，上面的 Title 所对应的输入框你也可以输入一个该 SSH key 显示在 github 上的一个别名。默认的会使用你的邮件名称。 测试一下SSH key 在git Bash 中输入以下代码 $ ssh -T git@github.com 当你输入以上代码时，会有一段警告代码，如： The authenticity of host 'github.com (207.97.227.239)' can't be established. # RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. # Are you sure you want to continue connecting (yes/no)? 这是正常的，你输入 yes 回车既可。 如果你创建 SSH key 的时候设置了密码，接下来就会提示你输入密码，如： `Enter passphrase for key '/c/Users/Administrator/.ssh/id_rsa':` 当然如果你密码输错了，会再要求你输入，直到对了为止。 注意：输入密码时如果输错一个字就会不正确，使用删除键是无法更正的。 密码正确后你会看到下面这段话，如： Hi username! You've successfully authenticated, but GitHub does not # provide shell access. 如果Hi后面的用户名是正确的,你已经成功设置SSH密钥。如果你看到 “access denied” ，者表示拒绝访问，那么你就需要使用 https 去访问了。 这样进行远程仓库操作的时候就需要输入密码，本地记住密码，只需要执行下面的这条命令 git config --global credential.helper store Git 配置 git config -e [--global] # 编辑Git配置文件 配置用户名和邮箱 用户名邮箱作用 : 我们需要设置一个用户名 和 邮箱, 这是用来上传本地仓库到GitHub中, 在GitHub中显示代码上传者; 使用命令： git config --global user.name \"yourname\" //设置用户名 git config --global user.email \"your email\" //设置邮箱 配置自动换行 git config --global core.autocrlf input #提交到git是自动将换行符转换为lf 彩色的git输出 git config --global color.ui true 配置别名 git config --global alias.st status #git st git config --global alias.co checkout #git co git config --global alias.br branch #git br git config --global alias.ci commit #git ci 设置显示中文文件名 git config –-global core.quotepath false 获取配置列表和帮助 git config --list #查看配置的信息 git help config #获取帮助信息 创建一个工程需要的操作流程 新建仓库 touch README.md git init git add README.md git commit -m \"first commit\" git remote add origin git@github.com:qiqihaobenben/Front-End-Basics.git git push -u origin master 从现有仓库克隆 git clone git@github.com:qiqihaobenben/Front-End-Basics.git git clone git@github.com:qiqihaobenben/Front-End-Basics.git myfile #克隆到自定义文件夹 git clone -o jQuery https://github.com/jquery/jquery.git # 更改远程主机的名字 之后操作跟上述相同，省略remote这一步。 推荐资料 GitHub超详细图文攻略 - Git客户端下载安装 GitHub提交修改源码工作流程 "},"assistive-tools/git/theory.html":{"url":"assistive-tools/git/theory.html","title":"基础和原理","keywords":"","body":"基础和原理 基础 保存的是文件的完整快照，而不是差异变化或者文件补丁 其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 疑问：如果我的项目大小是10M，那Git占用的空间是不是随着提交次数的增加线性增加呢？我提交（commit）了10次，占用空间是不是100M呢？很显然不是， 为了高效，如果文件没有修改，Git 不再重新存储该文件，它只会保存一个指向上一个版本的文件的指针，即，对于一个特定版本的文件，Git只会保存一个副本，但可以有多个指向该文件的指针。 近乎所有的操作都是本地执行 举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。这也意味着你离线时，几乎可以进行任何操作。 如你在飞机或火车上想做些工作，你能愉快地提交，直到有网络连接时再上传 三种状态 已修改（modified） 表示修改了某个文件，但还没有提交保存； 已暂存（staged） 表示把已修改的文件放在下次提交时要保存的清单中，即暂存区域； 已提交（committed） 表示该文件已经被安全地保存在本地版本库中了。 三个工作区域 1.工作区就是你在电脑上看到的目录，或者以后需要再新建的目录文件等等都属于工作区范畴。 2.暂存区运行git add命令后文件保存的区域，也是下次提交将要保存的文件 注意： Git 提交实际读取的是暂存区域的内容，而与工作区域的文件无关，这也是当你修改了文件之后，如果没有添加git add到暂存区域，并不会保存到版本库的原因 作用:作为过渡层避免误操作保护工作区和版本区分支处理 3、版本区（本地仓库）工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 原理 SHA-1校验和 Git 是一套内容寻址文件系统。意思就是Git 从核心上来看不过是简单地存储键值对（key-value），value是文件的内容，而key是文件内容与文件头信息的 40个字符长度的 SHA-1 校验和。例如：5453545dccd33565a585ffe5f53fda3e067b84d8。Git使用该校验和不是为了加密，而是为了数据的完整性，它可以保证，在很多年后，你重新checkout某个commit时，一定是它多年前的当时的状态，完全一摸一样。当你对文件进行了哪怕一丁点儿的修改，也会计算出完全不同的 SHA-1 校验和，这种现象叫做“雪崩效应”（Avalanche effect）。 文件(blob)对象，树(tree)对象，提交(commit)对象 简单来说，blob对象保存文件的内容；tree对象类似文件夹，保存blob对象和其它tree对象；commit对象保存tree对象，提交信息，作者，邮箱以及上一次的提交对象的ID（第一次提交没有）。而Git就是通过组织和管理这些对象的状态以及复杂的关系实现的版本控制以及以及其他功能如分支。具体可以参考http://blog.codingplayboy.com/2017/03/23/git_internal/ Git的引用 如果我们想要看某个提交记录之前的完整历史，就必须记住这个提交ID，但提交ID是一个40位的 SHA-1 校验和，难记。所以引用就是SHA-1 校验和的别名，存储在.git/refs文件夹中。最常见的引用也许就是master了，因为这是Git默认创建的（可以修改，但一般不修改），它始终指向你项目主分支的最后一次提交记录。存放位置.git/refs/heads/master Git的tag 标签从某种意义上像是一个引用， 它指向一个 commit 对象而不是一个 tree，包含一个标签，一组数据，一个消息和一个commit 对象的指针。但是区别就是引用随着项目进行，它的值在不断向前推进变化，但是标签不会变化——永远指向同一个 commit，仅仅是提供一个更加友好的名字。 Git的分支 Git保存文件的最基本的对象是blob对象，Git本质上只是一棵巨大的文件树，树的每一个节点就是blob对象，而分支只是树的一个分叉。说白了，分支就是一个有名字的引用，它包含一个提交对象的的40位校验和，所以创建分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，所以自然就快了，而且与项目的复杂程度无关。 在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。优点： 稳定版本的代码不会被破坏 不同的功能可以由不同开发者同时开发。 开发者可以专注于自己的分支，不用担心被其他人破坏了环境 在不确定之前，同一个特性可以拥有几个版本，便于比较 创建分支Git的默认分支是master，存储在.git\\refs\\heads\\master文件中，假设你在master分支运行git branch dev创建了一个名字为dev的分支，那么git所做的实际操作是： 在.git\\refs\\heads文件夹下新建一个文件名为dev（没有扩展名）的文本文件。 将HEAD指向的当前分支（当前为master）的40位SHA-1 校验和外加一个换行符写入dev文件。 结束。 切换分支的实际操作 修改.git文件下的HEAD文件为ref: refs/heads/。 按照分支指向的提交记录将工作区的文件恢复至一模一样。 结束。 推荐资料 Git的核心概念 "},"assistive-tools/git/directory.html":{"url":"assistive-tools/git/directory.html","title":"目录讲解","keywords":"","body":"目录讲解 .git目录 在初始化项目仓库时（git clone 或git init），Git会在根目录下创建一个.git目录，.git目录一般包括下面的内容： config ：文件包含项目的配置信息 index ： 文件存储着暂存区的内容信息 HEAD ：文件指向当前分支 ORIG_HEAD : 文件记录的是在进行极端（drastic）操作（如合并merge，回退reset等）时，此操作之前HEAD所指向的位置 hooks/ ： 目录存放项目的客户端或服务端钩子脚本 info/ ： 目录下的exclude文件包含项目全局忽略匹配模式，与.gitignore文件互补 refs/ ：目录存储着所有分支指向各自提交对象的指针 objects/ ：目录存储着Git数据库的所有内容 config config是仓库的配置文件，一个典型的配置文件如下，我们创建的远端，分支都在配置文件里有表现； fetch操作的行为也是在这里配置的 [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote \"origin\"] url = git@github.com:qiqihaobenben/Front-End-Basics.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master objects 通过SHA-1校验和存取的数据都位于objects目录objects目录下有3种类型的数据： Blob： 文件都被存储为blob类型的文件 Tree： 文件夹被存储为tree类型的文件 Commit： 创建的提交节点被存储为commit类型数据 refs refs目录存储都是引用文件，如本地分支，远端分支，标签等 refs/heads/xxx 本地分支 refs/remotes/origin/xxx 远端分支 refs/tags/xxx 本地tag 引用文件的内容都是40位commit 42223b40d4cd156276905c5a868b39ee50b10ecb HEAD HEAD文件存储的是当前所在的位置，其内容是引用的分支的名字：ref: refs/heads/master ORIG_HEAD ORIG_HEAD记录的是在进行极端（drastic）操作（如合并merge，回退reset等）时，此操作之前HEAD所指向的位置，便于我们在发生毁灭性失误时进行回退，如使用git reset --hard ORIG_HEAD指令可以回退到危险操作之前的状态，但是对于正常的提交操作，该指针是不会变化的。在1.8.5版本以后，Git使用了链表记录HEAD的所有移动轨迹，可以使用git reflog查看，使用git reset HEAD@方式可以回退到指定版本，这也是之后介绍Git数据恢复将要介绍的一个指令，推荐使用这种方式替代ORIG_HEAD方式。 更为详细的介绍-英文版 "},"assistive-tools/git/setconfig.html":{"url":"assistive-tools/git/setconfig.html","title":"基础操作配置","keywords":"","body":"Git 配置和.gitignore Git 配置 git config -e [--global] # 编辑Git配置文件 配置用户名和邮箱 用户名邮箱作用 : 我们需要设置一个用户名 和 邮箱, 这是用来上传本地仓库到GitHub中, 在GitHub中显示代码上传者; 使用命令： git config --global user.name \"yourname\" //设置用户名 git config --global user.email \"your email\" //设置邮箱 配置自动换行 git config --global core.autocrlf input #提交到git是自动将换行符转换为lf 彩色的git输出 git config --global color.ui true 配置别名 git config --global alias.st status #git st git config --global alias.co checkout #git co git config --global alias.br branch #git br git config --global alias.ci commit #git ci 设置显示中文文件名 git config –global core.quotepath false 获取配置列表和帮助 git config --list #查看配置的信息 git help config #获取帮助信息 .gitignore文件 屏蔽文件 : .gitignore文件是告诉Git哪些目录或者文件需要忽略, 这些文件将不被提交; .gitignore位置 : 项目根目录下; 过滤模式 : Git中的 .gitignore 中有两种模式,开放模式 和保守模式,保守模式的优先级要高于开放模式; 开放模式 : 设置哪些文件和目录被过滤, 凡是在文件中列出的文件或者目录都要被过滤掉; -- 过滤目录 : /bin/ 就是将bin目录过滤, 该文件下的所有目录和文件都不被提交; -- 过滤某个类型文件 : *.zip *.class 就是过滤zip 和 class 后缀的文件, 这些文件不被提交; -- 过滤指定文件 : /gen/R.java, 过滤该文件, 该文件不被提交; 保守模式 : 设置哪些文件不被过滤, 凡是列在其中的文件都要完整的提交上去; -- 跟踪目录 : !/src , 该目录下的所有文件都要被提交; -- 跟踪某类文件 : !*.java , 凡是java文件都要保留; -- 跟踪指定文件 : !/AndroidManifest.xml , 该文件需要保留, 提交上去; 配置原则 : 一般情况下采用开放模式鱼保守模式共同使用; eg : 一个目录下有很多目录和文件, 当我们只需要保留其中的一个文件的时候, 先用开放模式不保留这些文件, 然后用保守模式将这个文件留下来, 保守模式的优先级要高于开放模式; 具体操作 在项目根目录创建.gitignore文件 在文件中列出不需要提交的文件名，文件夹名，每个一行 .gitignore文件需要提交，就像普通文件一样 通常会被ignore的文件有： log文件 task runner builds node_modules等文件夹 IDEs生成的文件 个人笔记 例如 *.log build/ node_modules/ .idea/ my_notes.txt "},"assistive-tools/git/command.html":{"url":"assistive-tools/git/command.html","title":"命令汇总","keywords":"","body":" 在使用的任何的 git 命令前，都要切换到 git 项目目录下 常用命令 git init初始化一个 git 仓库 git status查看当前 git 仓库的状态 git log查看提交记录 添加和提交 git add [files] #把当前文件放入暂存区域 git add * # 把所有修改文件放入暂存区域 git add -u [path] # 添加[指定路径下]已跟踪文件 git commit # 给暂存区域生成快照并提交到本地版本库 git commit [file1] [file2] ... # 提交指定文件，对于跟踪过的文件，也可以不用git add，直接git commit file提交到本地版本库 git commit -m 'message' #添加注释 git commit -a # 跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交,注意是已经跟踪过的，对Untracked files无效 git commit --amend # 修改最后一次提交,git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。 git commit -v # 提交时显示所有diff信息 相关补充：提交信息规范 恢复相关的操作 文件删除相关 rm *&git rm * # 第一个命令移除工作区文件，第二个命令本地已经删除了的文件，通过此命令把暂存区的文件也删除了。 git rm -f * # 工作区和暂存区都有文件，运行此命令，会把两个文件都删除 git rm --cached * # 停止追踪指定文件，但该文件会保留在工作区 git mv file_from file_to # 重命名跟踪文件 查看历史记录 git log # 查看最近的提交日志 # 每次提交都有一个唯一id，可以查看所有提交和他们的id，之后恢复会用到 git log --pretty=oneline #单行显示提交日志 --pretty: 指定默认不同格式展示信息 git log --graph # 显示 ASCII 图形表示的分支合并历史。 git log --graph --oneline #oneline只是让输出看起来比较舒服,只显示最开始7个字符长度的 SHA-1 校验和。 git log --author=cfangxu #只看某个人的提交记录 git log --abbrev-commit # 显示log id的缩写 git log -num #显示几条log（倒数） git log --stat # 简略的显示每次提交的内容更改, 如哪些文件变更,多少删除,多少添加等 git log --follow [file] # 显示某个文件的版本历史，包括文件改名 git log -p [file] # 显示指定文件相关的每一次diff git log -p -x # 仅显示最近x次的提交,包含每一次的diff 搜索调试 git reflog # 查看已经修改的版本号，即使是已经删除的某个分支 git blame file.name # 快速显示文件的每一行最后一次修改是谁 git log -S --oneline # 在Git的整个历史中进行搜索 对比相关 git show commitId # 查看某一次提交更新了什么 git diff file #查看指定文件的差异(工作区和暂存区) git diff --stat #查看简单的diff结果(工作区和暂存区) git diff #比较工作区和暂存区之间的差异 git diff --cached(--staged) #比较暂存区和版本库之间的差异 git diff HEAD #比较工作区和版本库之间的差异 git diff branch #比较工作区和分支之间的差异 git diff branch1 branch2 #比较两次分支之间的差异 git diff commit commit #比较两次提交之间的差异 撤销相关 git reset HEAD # 取消已经暂存的文件 git reset -- # 同上,可以用git reset 撤销所有暂存区域文件。 git reset --hard HEAD # 恢复到当前版本库的状态，会覆盖工作区和缓存区的文件 git reset --hard commit(id) # 通过提交id来恢复之前的某个版本 git reset --hard HEAD^ # 跳到之前的一个版本，可以连续使用 git reset --hard HEAD~ # 跳过num个版本，到想要的版本。 checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。当给定某个文件名（或者打开-p选项，或者文件名和-p选项同时打开）时，git会从指定的提交中拷贝文件到暂存区域和工作目录。如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。注意当前分支不会发生变化。 git checkout -- file # 取消在工作区对文件的修改（从暂存区——覆盖工作区） git checkout -- . # 从暂存区取出文件覆盖工作区 git checkout branch|tag|commit -- file_name # 从仓库取出file覆盖当前分支 分支 创建分支 git branch # 列出本地分支 git branch -r # 列出远端分支 git branch -a # 列出所有分支 git branch -v # 查看各个分支最后一个提交对象的信息 git branch --merged # 查看已经合并到当前分支的分支 git branch --no-merged # 查看未合并到当前分支的分支 git branch test # 新建test分支 git branch branch [branch|commit|tag] # 从指定位置出新建分支 git branch --track branch remote-branch # 新建一个分支，与指定的远程分支建立追踪关系 git branch -m old new # 重命名分支 git branch -d test # 删除test分支 git branch -D test # 强制删除test分支 git branch --set-upstream-to origin/dev dev # 在dev执行，将本地dev分支与远程dev分支之间建立链接 git checkout test # 切换到test分支 git checkout -b test # 新建+切换到test分支 git checkout -b test dev # 基于dev新建test分支，并切换 合并分支 git merge test # 将test分支合并到当前分支, git merge –-no-ff test # 强制指定为非快速合并（no-fast-forward） git merge --squash test ## 合并压缩，将test上的commit压缩为一条,svn的在合并分支时采用的就是这种方式，squash会在当前分支新建一个提交节点 squash和no-ff非常类似，区别只有一点不会保留对合入分支的引用 git cherry-pick commitId # \"复制\"一个提交节点并在当前分支做一次完全一样的新提交。 git cherry-pick -n commit # 拣选多个提交，合并完后可以继续拣选下一个提交 git rebase master # 将master分支上超前的提交，变基到当前分支，本质上，这是线性化的自动的 cherry-pick git rebase --onto master 169a6 # 限制回滚范围，rebase当前分支从169a6以后的提交 git rebase --interactive # 交互模式 git rebase --continue # 处理完冲突继续合并 git rebase --skip # 跳过 git rebase --abort # 取消合并 合并推荐链接： 图解4种git合并分支方法 远程仓库 连接远程仓库 git remote add origin1 git@github.com:yanhaijing/data.js.git # 添加远程仓库 git remote # 显示全部源 git remote -v # 显示全部源+详细信息 git remote rename origin1 origin2 # 重命名 git remote rm origin # 删除 git remote show origin # 查看指定源的全部信息 操作远程仓库 git fetch origin remotebranch[:localbranch] # 从远端拉取分支[到本地指定分支] git merge origin/branch # 合并远端上指定分支 git pull origin remotebranch:localbranch # 拉取远端分支到本地分支 git pull origin master --allow-unrelated-histories # 允许拉取远端无关历史的master分支到本地当前分支 git push origin branch # 将当前分支，推送到远端上指定分支 git push origin localbranch:remotebranch # 推送本地指定分支，到远端上指定分支 git push origin :remotebranch # 删除远端指定分支 git push origin remotebranch --delete # 删除远程分支 git branch -dr branch # 删除本地和远程分支 git checkout -b [--track] test origin/dev#基于远端dev分支，新建本地test分支[同时设置跟踪] 推荐资源：Git远程操作详解 工作现场 git stash # 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。 git stash list # 查看保存的工作现场 git stash apply # 恢复工作现场 git stash drop # 删除stash内容 git stash pop # 恢复的同时直接删除stash内容 git stash apply stash@{0} # 恢复指定的工作现场，当你保存了不只一份工作现场时。 链接：里面有介绍工作现场 标签 标签作用: 在开发的一些关键时期,使用标签来记录这些关键时刻, 例如发布版本, 有重大修改, 升级的时候, 会使用标签记录这些时刻, 来永久标记项目中的关键历史时刻; git tag # 列出现有标签 git tag v0.1 [branch|commit] # [从指定位置]新建标签 git tag -a v0.1 -m 'my version 1.4'#新建带注释标签 git checkout tagname # 切换到标签 git push origin v1.5 # 推送分支到源上 git push origin --tags # 一次性推送所有分支 git tag -d v0.1 # 删除标签 git push origin :refs/tags/v0.1 # 删除远程标签 链接：里面有关于标签的操作 推荐资源 图解Git "},"project/el-scrollbar.html":{"url":"project/el-scrollbar.html","title":"el-scrollbar讲解","keywords":"","body":"Vue的自定义滚动，我用el-scrollbar 为什么要用el-scrollbar？ 最近在写一个内部平台系统，相信大家都知道，其中会有很多自定义的滚动区域，就比如说现在有一个列表需要滚动，第一个念头就是用 overflow: scroll; 啊！嗯嗯，又不是不能用！如果我不曾见过太阳，我本可以忍受黑暗。 大家总会见过不少滚动条比较优雅的实现，不可否认，美是让人愉悦的。所以这些年行走江湖我满怀愧疚，让大家见丑了。 为什么要用el-scrollbar，大家都知道，模拟一个滚动不难，而且市面上有很多这样的库。我考虑的，首先项目用的框架是Vue，然后用的组件库是Element，Element官网也有很多滚动，而且像是Select组件的下拉框也是有滚动的，所以就不用想选择什么了，简简单单的就用Element自己的scrollbar吧，也不用再引入什么别的包或者文件之类的。 看Element的官网是不可能发现Scrollbar这个组件的，没有使用文档，但是可以直接使用。 为什么要写这一篇文章？ 第一，有段时间没写东西了，先热热手； 第二，真的有同学不知道怎么用，可能主要是没有文档吧~ 先来看看它的样子。 看了效果，接着来看一下怎么找到这个组件，官方没有提供文档，但确实是直接可用的一个组件。为什么这么说，这个一会再聊。先稍微看一下Element项目一些基本的概念。 在Element的贡献指南里说了开发环境搭建和打包代码的指令。打包代码用 npm run dist ,我们去package.json中可以看到这个指令具体的操作。 我们简单看一下build/webpack.conf.js这个文件，会发现打包的文件入口是./src/index.js,我们再去看一下这个文件。里面内容除了包含给vue安装插件，原型上挂载对象之类的操作外，就是用插件的方式把Element组件给注册完成，当然也暴露出用安装包方式安装后要用的所有方法和属性。其实我们已经看到了Scrollbar的身影。再循着去看一下packages/scrollbar/index.js'这个文件，简单的把这个组件引入后，添加了一个install方法，提供给Vue的use方法使用，然后就直接export出来了。 去src/main.js这个文件，看一下组件接收的props: native属性：如果为true就不显示el的bar，也就是el模拟出来的滚动条，如果为false就显示模拟的滚动条 关于tag这个属性，可以看一下el的Select组件中的应用。 画个图表示一下view和wrap这两个区域的区别： 尝试用一下 展示的链接：el-scrollbar试用 考虑到有些同学有时会打不开上面的链接，把代码贴出来。 HTML list: {{value}} CSS @import url(\"//unpkg.com/element-ui@2.3.9/lib/theme-chalk/index.css\"); #app { height: 300px; overflow: hidden; } /*展示列表的区域，超过200px出现滚动条*/ .list { max-height: 200px; } JavaScript new Vue({ el: \"#app\", data: { num: 30 } }) Element UI官方说不准什么时候就更新文档了，不过，真的可能是因为太简单了。 "},"article/book.html":{"url":"article/book.html","title":"买了书也不读，还要不要买？","keywords":"","body":"买了书也不读，还要不要买？ 原文链接 题图：from zoommy 这几天看书的时候，顺便整理了一下书架，原意是把没用的、不准备再读的书收起来，留下准备读和重复阅读的书籍。整理的结果让我大吃一惊，除了一些老旧的技术图书，大部分书都是我准备要读或者曾经准备要读的。这两年纸书堆积如山，其中一半是自己买的，另一半是出版社或其他朋友送的，虽然时时在读，但竟然只读了一小部分。整理的时候，大部分图书都是簇新的。有些书塑封还在，拆开翻阅，新书散发着油墨的书香，我一般翻一边发愣，怎么会有这么多书没看呢？ 买书如山倒，读书如抽丝，看来这句话说的一点错也没有。几十年来，房价窜升到了九霄云外，纸书的价格却自巍然不动，只要工作几年，买书就成了负担很轻的消费。有时碰到一本好书，还可能给你带来不可估量的收益。所以，看到一本好书 —— 至少那时候觉得好 —— 我基本上都会冒着不读的风险买下来。过一阵子从书架上拿下来吹去浮尘翻一翻说，咦，果然没读，然后又放了上去。 为什么明知道买书不读还要买呢？我把这个问题扔到了朋友圈。收到了朋友圈的朋友们各式各样的回复： 买了再说，万一要是读了呢？ 那些年看过的书皮 享受买书的过程 要的是拥有的感觉 为了满足万一想读就能读的控制欲 哦……我认为买书是一种信仰 我每次学新东西，就会买本书放书柜上，马上就有种学会了的感觉，特别棒 你们说的都对！ 从理性角度我很清楚，书架上的图书，在相当长的一段时间内是读不完的，甚至，有些书可能永远都不会读了，一想到这一点我就非常伤感。但见到「好书」，还是会毫不犹豫的买下，无论是电子还是纸质。因为买书可以让人产生一种无与伦比的安全感。 社会越来越复杂，节奏越来越快，选择越来越多，信息的浪潮汹涌澎湃。人们想的太多，做的又太少，在知识的大潮中慌不择路，这时候很多人（包括我）突然发现了一种抗拒焦虑、获取知识的捷径：收藏知识。 从网上下单，付费，收到快递，拆开包装，购书的喜悦油然而生，然后我们喜滋滋的把这本书放在理自己最近的地方，然后等待下一本新书取代它的位置。 Evernote 的剪藏，各种「稍后读」的阅读工具，各类电子书平台，对于很多人来说，都是在收藏知识，因为「反正以后会读的」。至于以后读不读，那是未来的事情，未来嘛，很难讲的。 当然了，收藏知识对我来说，也不是一无是处，毕竟我在一本一本的读着。就像我之前写的，先把一件事情做成，然后再去做另一件事。书读不完不用着急，先读完一本试试。走得慢不要紧，只要你在一直往前走。还没红？继续努力，万一你是大器晚红呢。这么一想，感觉就会好很多。 另外，生活中我们总会遇到某个瞬间，突然想急迫的了解某个领域的知识，这时候如果可以随时抽出书架上一本书翻阅并帮助你答疑去惑，那种解燃眉之急的感觉，就像漆黑的旷野突然被一道闪电照亮，就像猴子终于吃到了香蕉，就像你找到了灌木丛中丢失的手机赶紧回了一条微信那么舒爽。 买书、读书还不够，我们得能找到好书，知道如何去阅读一本书。我在「失业」那篇文章里谈到了好书的概念（因为那篇的重点是失业，这段话基本上被忽略了）。 我最近在文章中多次提到读好书的概念，实在是因为我对读书这件事领悟的太晚。小时候杂七杂八读了不少烂书，上大学到毕业工作期间，因为生存问题又读了大量的技术书，真正读到并能够理解的好书屈指可数。慢慢读的书越多，越发现要读到读懂那些经典和名著，是需要运气的。 你得生长在一个不错的知识分子家庭，有好的教育，成长的不同阶段有人告诉你该去读什么书，怎么读书，然后你才能具备了一种阅读能力，帮助你去读很多别人没办法读进去的书。这个过程对我来说实在是太漫长了，因为大部分好书读起来都不是那么让人愉悦的，你需要踮起脚尖，硬着头皮读下去，就像新手进入一个新领域一样，没什么办法，只能坚持往前走。 做到这一点是如此困难，以至于很多人读一些好书都是「从阅读到放弃」，毕竟看一些爆米花文学或影视剧来的更轻松一些。 除了名师指点，自己如何找到并阅读一本好书呢？今天给大家推荐一本名著 ——《如何阅读一本书》。这本书首次出版于1940年，1972年大幅增补改写后重新出版，延续至今。梁文道老师在他主讲的《我读》系列图书中也推荐过。书中对阅读进行了层次划分，同一本书，因为性质和场景不同，你可以简读，速读，精读，甚至可以用业余学者的方式阅读。 有的人遇到看不懂的图书和文章就会骂作者写的烂，遇到浅显解惑的内容又会认为作者肤浅，却从来不考虑自己的阅读方式和理解问题。有的人希望快速阅读一本书，有的人希望找到好书，有的人则希望能够通读并拆解一本书……这些问题，都可以在本书中找到答案。没找到也别回头来怪我，因为我找着了。 读书和写作还有一个特别大的好处，就是抑制人们心中的恶，我在某问答社区上看到了很多人性的恶，我觉得他们只是在收藏知识，并没有阅读知识。当然，这是另一个话题了，也许会单起一篇去写。 好了，现在听我的，拿起一本书，心无旁骛的把它读完。然后拿起第二本书，再读……你会发现，读书还真是一挺难的事儿。 "},"article/read-book.html":{"url":"article/read-book.html","title":"为什么我要求你读书用功","keywords":"","body":"为什么我要求你读书用功 这篇文章自出《亲爱的安德烈》，是龙应台写她儿子的一封信，我非常喜欢这篇文章，准备当我的孩子上中学时读给他听。 作者：龙应台 安德烈： 　　我注意到，你很不屑于回答我这个问题：“你将来想做什么”，所以跟我胡诌一通。 　　是你们这个世代的人，对于未来太自信，所以不屑于像我这一代人年轻时一样，讲究勤勤恳恳，如履薄冰，还是，其实你们对于未来太没信心，太害怕，所以假装出一种嘲讽和狂妄的姿态，来闪避我的追问？ 　　我几乎要相信，你是在假装潇洒了。 　　今天的青年人对于未来，潇洒得起来吗？法国年轻人在街头呼喊抗议的镜头让全世界都震惊了：这不是上世纪六零年代的青年为浪漫的抽象的革命理想上街呐喊──带着花环、抱着吉他唱歌，这是21世纪的青年为了自己的现实生计在烦恼，在挣扎。你看看联合国2005年的青年失业率数字：比利时21.5％；澳洲22.6％；芬兰21.8％；法国20.2％；希腊26.3％；意大利27％；波兰41％；斯洛伐克32.9％；西班牙27.7％；英国12.3％；美国12.4％；德国10.1％；香港（15到24岁青年的失业率）9.7％；台湾10.59％。数字不见得精确的中国大陆，是9％。 　　你这个年龄的人的失业率，远远超过平均的失业率。巴黎有些区，青年人有百分之四十出了校门找不到工作。然后，如果把青年自杀率也一并考虑进来，恐怕天下作父母的都要坐立难安了。自杀，已经是美国15到24岁青年人的死因第一位。在台湾，也逐渐升高，是意外事故之后第二死因。世界卫生组织的数据说，全世界有三分之一的国家，青年是最高的自杀群。芬兰、爱尔兰、新西兰3个先进国家，青年自杀率是全球前三名。 　　你刻意闪避我的问题，是因为……21岁的你，还在读大学的你，也感受到现实的压力了吗？ 　　我们21岁的时候，上世纪70年代，正是大多数国家经济要起飞的时候。两脚站在狭窄的泥土上，眼睛却望向开阔的天空，觉得未来天大地大，什么都可能。后来也真的是，魔术一般，眼睁睁看着贫农的儿子做了总统；渔民的女儿，成了名医；面摊小贩的儿子，做了国际律师；码头工人的女儿，变成大学教授；蕉农的儿子，变成领先全球的高科技企业家。并非没有人颠沛失意，但我们真的是“灰姑娘”的一代人啊，安德烈，在我们的时代里，我们亲眼目睹南瓜变成金色的马车，辚辚开走，发出真实的声音。我身边的朋友们，不少人是教授、议员、作家、总编辑、律师医师、企业家科学家出版家，在社会上看起来仿佛头角峥嵘，虎虎生风。可是，很多人在内心深处其实都藏着一小片泥土和部落──我们土里土气的、卑微朴素的原乡。表面上也许张牙舞爪，心里其实深深呵护着一个青涩而脆弱的起点。 　　如果有一天，我们这些所谓“社会精英”同时请出我们的父母去国家剧院看戏，在水晶灯下、红地毯上被我们紧紧牵着手蹒跚行走的，会有一大片都是年老的蕉农、摊贩、渔民、工人的脸孔──那是备受艰苦和辛酸的极其朴拙的脸孔。他们或者羞怯局促，或者突然说话，声音大得使人侧目，和身边那优游从容、洞悉世事的中年儿女，是两个阶级、两个世界的人。 　　你的20岁，落在21世纪初。今天美国的青年，要换第4个工作之后，才能找到勉强志趣相符的工作。在“解放”后的东欧，在前苏联地区的大大小小共和国，青年人走投无路。在先进的西欧，青年人担心自己的工作机会，都外流到了印度和中国。从我的20岁到你的20岁，安德烈，人类的自杀率升高了百分之六十。 　　于是我想到提摩。 　　你记得提摩吧？他从小爱画画，在气氛自由、不讲究竞争和排名的德国教育系统里，他一会儿学做外语翻译，一会儿学做锁匠，一会儿学做木工。毕业后找不到工作，一年过去了，两年过去了，三年又过去了，现在，应该是多少年了？我也不记得，但是，当年他失业时只有18岁，今年他41岁了，仍旧失业，所以和母亲住在一起。没事的时候，坐在临街的窗口，提摩画长颈鹿。长颈鹿的脖子从巴士顶伸出来。长颈鹿穿过飞机场。长颈鹿走进了一个正在放映电影的戏院。长颈鹿睁着睫毛长长的大眼，盯着一个小孩骑三轮车。长颈鹿在咀嚼，咀嚼，慢慢咀嚼。 　　因为没有工作，所以也没有结婚。所以也没有小孩。提摩自己还过着小孩的生活。可是，他的母亲已经快80岁了。 　　我担不担心我的安德烈──将来变成提摩？ 　　老实说……是的，我也担心。 　　我记得我们那晚在阳台上的谈话。 　　那是多么美丽的一个夜晚，安德烈。多年以后，在我已经很老的时候，如果记忆还没有彻底离开我，我会记得这样的夜晚。无星无月，海面一片沉沉漆黑。可是海浪扑岸的声音，在黑暗里随着风袭来，一阵一阵的。猎猎的风，撩着玉兰的阔叶，哗哗作响。在清晨3点的时候，一只蟋蟀，天地间就那么一只孤独的蟋蟀，开始幽幽地唱起来。 　　你说：“妈，你要清楚接受一个事实，就是，你有一个极其平庸的儿子。” 　　你坐在阳台的椅子里，背对着大海。清晨3点，你点起烟。 　　中国的朋友看见你在我面前点烟，会用一种不可置信的眼光望向我，意思是──他他他，怎么会在母亲面前抽烟？你你你，又怎么会容许儿子在你面前抽烟？ 　　我认真地想过这问题。 　　我不喜欢人家抽烟，因为我不喜欢烟的气味。我更不喜欢我的儿子抽烟，因为抽烟可能给他带来致命的肺癌。 　　可是，我的儿子21岁了，是一个独立自主的成人。是成人，就得为他自己的行为负责，也为他自己的错误承担后果。一旦接受了这个逻辑，他决定抽烟，我要如何“不准许”呢？我有什么权力或权威来约束他呢？我只能说，你得尊重共处一室的人，所以请你不在室内抽烟。好，他就不在室内抽烟。其他，我还有什么管控能力？ 　　我看着你点烟，翘起腿，抽烟，吐出一团青雾；我恨不得把烟从你嘴里拔出来，丢向大海。可是，我发现我在心里对自己说，MM请记住，你面前坐着一个成人，你就得对他像对待天下所有其他成人一样。你不会把你朋友或一个陌生人嘴里的烟拔走，你就不能把安德烈嘴里的烟拔走。他早已不是你的“孩子”，他是一个个人。他就是一个“别人”。 　　我心里默念了3遍。 　　安德烈，青年成长是一件不容易的事，大家都知道；但是，要抱着你、奶着你、护着你长大的母亲学会“放手”，把你当某个程度的“别人”，可也他妈的不容易啊！ 　　“你哪里‘平庸’了？”我说，“‘平庸’是什么意思？” 　　“我觉得我将来的事业一定比不上你，也比不上爸爸——你们俩都有博士学位。” 　　我看着你……是的，安德烈，我有点惊讶。 　　“我几乎可以确定我不太可能有爸爸的成就，更不可能有你的成就。我可能会变成一个很普通的人，有很普通的学历，很普通的职业，不太有钱，也没有名。一个最最平庸的人。” 　　你捻熄了烟，在那无星无月只有海浪声的阳台上，突然安静下来。 　　然后你说，“你会失望吗？” 　　海浪的声音混在风里，有点分不清哪个是浪，哪个是风。一架飞机闷着的嗡嗡声从云里传来，不知飞往哪里。蟋蟀好像也睡了。你的语音轻轻的。这样的凌晨和黑夜，是灵魂特别清醒的时候，还没换上白天的各种伪装。 　　我忘了跟你怎么说的──很文艺腔地说我不会失望，说不管你做什么我都高兴因为我爱你？或者很不以为然地跟你争辩“平庸”的哲学？或者很认真地试图说服你——你并不平庸只是还没有找到真正的自己？ 　　我不记得了，也许那晚葡萄酒也喝多了。但是，我可以现在告诉你，如果你“平庸”，我是否“失望”。 　　对我最重要的，安德烈，不是你有否成就，而是你是否快乐。而在现代的生活架构里，什么样的工作比较可能给你快乐？第一，它给你意义；第二，它给你时间。你的工作是你觉得有意义的，你的工作不绑架你使你成为工作的俘虏，容许你去充分体验生活，你就比较可能是快乐的。至于金钱和名声，哪里是快乐的核心元素呢？假定说，横在你眼前的选择是到华尔街做银行经理或者到动物园做照顾狮子河马的管理员，而你是一个喜欢动物研究的人，我就完全不认为银行经理比较有成就，或者狮子河马的管理员“平庸”。每天为钱的数字起伏而紧张而斗争，很可能不如每天给大象洗澡，给河马刷牙。 　　当你的工作在你心目中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。 　　我怕你变成画长颈鹿的提摩，不是因为他没钱没名，而是因为他找不到意义。我也要求你读书用功，不是因为我要你跟别人比成就，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。 　　如果我们不是在跟别人比名比利，而只是在为自己找心灵安适之所在，那么连“平庸”这个词都不太有意义了。“平庸”是跟别人比，心灵的安适是跟自己比。我们最终极的负责对象，安德烈，千山万水走到最后，还是“自己”二字。因此，你当然更没有理由去跟你的上一代比，或者为了符合上一代对你的想象而活。 　　同样的，抽烟不抽烟，你也得对自己去解释吧。 "},"article/critical-knowledge.html":{"url":"article/critical-knowledge.html","title":"临界知识","keywords":"","body":"临界知识 原文链接 《好好学习 - 个人知识管理精进指南》成甲著 这本书主要讲了“临界知识”这个概念，所谓“临界知识”，便是我们经过深度思考后发现的具有普遍指导意义的规律或者定律。 但是我觉得这本书更有意义的是第四章的几个临界知识的讲解和应用。那么此次分享我们就着重讲3个重要临界知识：黄金思维圈、系统思考、安全空间。 在开始之前，请大家自己心里想想，你是怎么理解这三个概念的：黄金思维圈、系统思考、安全空间。 带着你的理解，在我讲解的过程中，对比看看，你跟作者想的是否一致。 黄金思维圈 黄金思维圈的最基本应用就是：凡事首先要问“为什么” 从why开始思考和表达，听起来理所当然。然后做起来又是另一码事。比如：领导给了一个开发任务，我们大部分人就是确定功能点，就开干了。可是这个功能是解决什么问题？为什么这么做？这么设计的最根本原因是什么？是否有更好的办法可以解决这个需求? 从why思考，你会发现有很多的what其实并不是看起来的样子，根据why做事情，可以把事情做得更准确，效果也最好。 例子：你要开一家水果店，周围已经有很多家了，怎样才能让你的店脱颖而出？ 通过询问以为购买水果的典型顾客：下班后的妈妈。 问：为什么大家喜欢新鲜的水果？顾客：新鲜的水果味道最好问：为什么味道好，对你如此重要？顾客：因为味道好，我的小孩就喜欢问：为什么孩子喜欢吃苹果对你很重要？顾客：苹果对他的健康好问：为什么健康对你如此重要？顾客：因为我想做一个好妈妈问：为什么照顾家庭对你很重要？ 顾客：这难道不是理所当然的吗？ 我们可以发现，购买信息水果这一行为背后是妈妈守护家庭安全、健康，做一个负责好妈妈的底层价值观动机。因此，我们可以将原先what层面描述“新鲜水果，快速送达”的宣传语，更换成类似“我们与您一起守护家人健康”的观点。 人与人的差别就在于他在哪个层面在思考这个问题。 在与人聊天的过程中，你可以通过对方是在哪个层面讨论问题，从而判断他对这一问题的深刻程度。于是你可以应用在招聘员工中：一大半的应聘者因为思考问题停留在what层面，就无法进入复试。 系统思考 网上的信息铺天盖地，一些诱导性的信息也是屡见不鲜，你是否也曾人云亦云的卷入过被群体利用并被收割的经历。《乌合之众》中提到，群体是无法思考的。我们要尽量避免群体一样的思考，形成自己独立的思考，是分辨真实世界的最有力武器。系统思考是一种有效的方式。 1、重要的是关系 事物本身最重要的是它们的组织，它们组合起来的模式和形式，也就是各个部分之间的关系。 石墨与钻石由相同的碳元素构成，只是碳元素的组织方式不同，展现出来的性质就截然不同。 2、时滞，是系统思考中非常关键的概念。 在一个系统中，当信息的反馈有时滞时，会产生“没什么问题”的假象。我们洗澡时，会不断的调整开关，以便达到合适的水温，要反复几次才能达到理想的温度，为什么？那是因为热水器和出水口有一段距离的“时滞”，需要我们试上多次才能消除“时滞”带来的误差。 3、找到关键解 系统关键解 — 指一个系统中的特定位置，对其施加一个小小的变化，就能导致系统行为发生显著的变化。 例子：美国美铝公司曾经一度业绩下滑，人们都期待新上任的CEO能提升产品竞争力、开发新产品等重振辉煌。新上任的CEO保罗.奥尼尔给出的答案是：减少公司生产的安全问题。当大家确信这位CEO要真的这么干的时候，很多人都赶紧卖出了公司的股票。结果，不到一年的时间，美铝就取得了空前的利润。提高盈利能力的答案是减少企业的安全问题？奥尼尔也是在理解了公司背后的运作系统后才做出了惊人的决定：提高生产安全性—》减少停工、次品减少—》成本降低、质量增加、产量激增、浪费减少—》增强竞争力—》更多收入。复杂系统的特征之一是“违反直觉的”。在纷繁复杂的表象背后，那个真正起作用的关键解可能让我们难以想象。 系统思考是一种与我们直觉思考不同的思考方式，这个世界不是简单的因果关系，理解事物最重要的方式是对事物之间的关系进行思考。这样，我们才能在芸芸众生中形成自己的独立见解。从日常的生活中注意观察表象背后的运作关系，对自己每天的行动给予指导，让系统思考这中思维方式切实带来价值。 安全空间 99个成功抵不过一个失败。由于幂律分布定律，小概率事件会造成极端严重的后果。 你有没有临到交稿或者演讲，却发现唯一的Word文件或者PPT文件打不开的经历？你有没有看到身边的人生了重病，却没有保险，跪地求救，发起募捐？如果你 或者你家里的赚钱主力突然失业了，没有工资，你的家庭生活会受到多大影响？ 先解释下什么是安全空间？为了确保系统的正常运行，或在极端的情况下，为了不造成无法挽回的结果所做的准备。比方说：为了防止爆胎，汽车后备箱里会有一个后备轮胎；为了防止漏电发生大的损失，家家都会装漏电保护器；为了家庭不被重疾和意外碰撞的支离破碎，人们会买保险～ 查理.芒格就说过这么一句话：“安全空间”这个概念是由一位很聪明的人在经历人生许多挫折后建立起来的，它非常有创造性。 我自己的安全空间例子，要给家人买一份意外和大病保险，给自己的电脑系统备份，给家里备好灭火和发生火灾的逃生装备等等。 可以从这几个方面来加强安全空间： 设计冗余备份（关键节点的备份） 提高决策质量，减少极端事件发生概率 提升系统的抗击打能力，把一个要承担极端严重后果的系统，变为一个持续承受冲击的小系统。 在一帆风顺的时候进行风险控制，是一件看起来很傻的事情，因为得不到验证。 但是我们要活在未来，构建自己的安全空间。安全空间一种思维方式，多主动思考这样一些情况，并采取措施，让自己在一个更安全的状态上，一旦出现极端情况，不至于出现“毁灭”的情况。 "},"article/seven-thing.html":{"url":"article/seven-thing.html","title":"七件事","keywords":"","body":"越优秀的人，越早想明白的七件事 原文链接 做公众号之后，我经常会收到粉丝提问。很多问题答过就忘了，但一年前的一个提问，到现在我还会时不时地想起。 那个粉丝的问题其实稀疏平常，真正让我吃惊的是他的年龄。 他问我，他应该继续工作，还是辞职考研？问题是，他已经三十多岁了。按照年龄算，他上小学的时候，我还没学会走路。到底是什么让他的心智如此晚熟，以至于到了而立之年还不知道自己到底想要什么？ 是因为认知，是因为对某些基础问题的认知模糊不清。 公众号请辩的创始人蔡垒磊在新书《认知突围》里说的一个观点，我很认同。他也经常从公众号后台收到粉丝提问，他发现这些提问虽然五花八门，但总是有许多共性，总是指向一些基础的概念。 他认为：“大多数人对于某些问题就是无能为力，这种无能为力背后是人们对影响人生关键的某些概念认识不清，从而总是无法做出正确的决定。” 回顾我遇到的那些迷茫的提问者，无论是面临情感抉择还是人生规划，他们有一个共同点：遇到问题习惯问别人怎么办，而不是问自己怎么办。他们身体成年了，心理却依然是一个茫然无措的孩子。 他们总是寄希望于别人给他指条道，寄希望于别人能提供一条可以直接复制模仿的生活路径，寄希望于别人能给他一个清晰的、现成的、能解决他生活问题的快捷方案。 他们就像巨婴一样，无法独立地思考，无法坚定地做选择，无法清晰地评估风险和机会。一些基础认知没有建立起来，他们就永远都是一个茫然无措的孩子。 但生活不会一直允许他们当一个茫然无措的孩子。25岁大多数人已经大学毕业并工作一两年了，25岁之前你可以理直气壮地迷茫，25岁之后有些事情拎不清，社会对你就不会那么宽容了。 早已成年却依然茫然的人，需要一场认知突围。而这些认知最好在25岁之前，就建立起来。 1、关于未来： 人生根本不存在一条既定的跑道 不知道从什么时候开始，“赢在起跑线”成了一句深入人心的口号。可是仔细想想，这句话有个很大的问题，它让人产生有种错觉，误以为人生有一条既定的跑道。 高考以前，某种意义上，我们和同龄人确实很像在一条跑道上。一群人按部就班地读完幼儿园读小学，读完小学读中学，在这个阶段，你很清楚地知道接下来会发生什么。所以只要努力争上游就好，不需要做什么选择。 迷茫通常是从高考后报志愿开始的，从那一刻开始，人生的选项就不断地递到你的手里： 去哪个城市？报哪个专业？选择哪个大学？读完本科要不要继续深造？回三线城市的老家还是待在大城市发展？工作要选择什么行业？哪个公司是更好的平台？和谁度过一生？要不要分手？要不要跳槽？什么时候买房？在哪儿买房…… 我们和同龄人浩浩荡荡地一同出发，然后在分岔路口奔跑着散开。 这个时候，你才会发现，真实的人生并不存在一条既定跑道，真实的人生是一个小径分叉的花园。每个人都需要去找到自己的路，找到自己要去的地方。 在小径分叉的花园里，每一条路都有自己的风景，根本无法像跑道一样简单地比拼出输赢。 所以，人生的成功并不是比别人成功，而是找到自己喜欢且擅长的事，按自己喜欢的方式安排人生。 彻底想明白这一点有什么好处？ 想明白这一点，你就不会再把自己和其他人放在一个假象的跑道上比较输赢，你最关心的不再是所谓的跑赢人生，而是找到自己想去的地方、找到到达那个地方的路径。 你会一头扎进自己的人生，而不是环顾左右，整天因为谁谁赚得比较多，谁谁混得比我好而焦虑。 你会专注地做属于自己的事情，不再羡慕也不再盲从，不再因为别人出国而出国，因为别人考研而考研，因为别人跳槽而跳槽，因为别人考公务员而考公务员。 你会开始追随你自己。 2、关于生命： 阅历是由生活的密度决定的 人们对年龄有一个刻板印象，认为活得长，见识就长，懂得就多。年长的人喜欢说：我走过的桥比你走过的路都多，我吃过的盐比你吃过的饭都多。 可是阅历并不是由年龄决定，而是由生活的密度决定的。 就像《认知突围》里说的：“单纯地计算经历过多少日出和日落，并不能完全反应出时间在人生刻度上留下的印记。有些人只需要几年就能走过一些人一辈子走过的路。” 当记者的时候，这种体会特别深，那个时候经常一天不止跑一条新闻，上午去的地方、接触的人、采访的新闻事件和下午可能完全不同，生活事件密集地发生，以至于过了一天像过了好几天。 我也迅速地沉稳练达起来，那段时间是我毕业后成长最快的时期，我甚至觉得一年的记者阅历顶得上其他人的五年。后来转行过起了朝九晚五的规律生活，生活仿佛从干饭变成了稀粥。 人生是短暂的，每个人终有一死，这是命定的结局，死亡一旦来临，所有得到的最终都会失去。所以重要的根本不是结果，而是过程，过程就是奖励。 人生其实就是一场体验，是选择一成不变地过一生，还是在短暂的一生里，尽可能地看更多风景、认识更多有趣的人、经历更多的不同的事？ 至少相比安稳，我更想要体验更多。 人生观是指导我们的人生选择的底层代码。我毕业之后去报社当记者，之后辞职进入新媒体，接着辞职开始自由职业，我很少觉得迷茫，因为只要想清楚了要如何度过这一生，面临形形色色选择的时候，我心里就和明镜似的。 同时还会获得一种不计得失、不畏虎狼的勇气：反正人生就是一场体验，我尽情体验就好了，得失并没有那么重要。 3、关于金钱： 想实现财务自由，要靠资产性收入 实现财务自由应该是每个人的梦想。可是怎么样才能实现财务自由呢？很残酷的真相是，除了少数高薪群体，大多数上班族靠每个月的死工资，根本不可能实现财务自由。 对于金钱也需要认知突围。 《认知突围》的作者认为，我们应该重新认识金钱。普通的收入通常分为两种，一种是资产性收入，即利用现有资本本身带来的收益，如房租收入、股权分红、版税收入等等；另一种是劳动性收入，即利用劳动换来的报酬，一旦停工就没有收入。 财务自由指的不是钱够用，而是指长期不劳动换取报酬，也充裕。财务自由的“自由”意味着不需要为了工资而工作，不再被工资捆绑。你可以选择你自己真正喜欢做的事，而不是为生活所迫地做那些你不乐意却又无可奈何要做的事。 靠停工就没收入的劳动性收入是无法实现财务自由的，所以在金钱方面，25岁之后要努力慢慢从纯劳动性收入，过渡到有一定比例的资产性收入，甚至完全靠资产性收入实现财务自由。25岁之后，除了升职加薪，还要学会投资理财。 4、关于人脉： 一直施恩才能维系的，叫劳动性人缘 小学的时候有个同学，经常拿一些好吃好玩的讨好同学，结果他有好吃好玩东西的时候，大家围着他转，一旦他没有好吃好玩的，大家对他就一下子冷了下来。而另外一个同学学习好、有什么难题问题问他，一准给你说得明明白白。虽然从未试着去讨好同学，大家却都喜欢和他玩。 类似这样的情况，成长的过程中碰到过很多。以前不明白这是为什么，后来隐约觉得这两种人社交效率完全不同，却没有清晰的思路说出两者的区别。 《认知突围》作者的分析让我一下子豁然开朗。他沿用了资产性收入和劳动性收入的概念，把人缘分为资产性人缘和劳动性人缘。 劳动性人缘需要时刻维持在劳动状态，也就是得一直处于施恩状态。他在大部分情况下十分被动，所维系的关系也十分脆弱。看似拥有许多人缘，可是一旦他拒绝别人的请求或者停止施恩，前期的积累也就跟着烟消云散了。 资产性人缘建立在个人的吸引力，来自于潜在的受益期望，哪怕你什么恩惠也不施，仍然有好人缘在。 这种资产，可以是财富、权力、名气、美貌，也可以是才华、品味、性格魅力、甚至有趣程度。资产性人缘，人人都想跟你建立关系、交换资源，和不和一个人“建交”，主动权掌握在自己的手里。 除了那些含着金汤匙出生的人，资产性人缘需要前期积累。 25岁之后要慢慢提升自己的个人价值，靠自己的个人价值吸引资产性人缘，成为别人想认识的人，不能一直是一个不起眼、不重要的边缘人，总靠施恩维系人脉，总是抬着头仰望优质人脉。 5、关于能力： 普通的人找工作，稀缺的人被工作找 在其他人焦头烂额找工作的时候，永远有一群人不愁工作，他们在职的时候是公司的重用对象，一离职，猎头挤破头地给他打电话。 是什么让他们在雇佣市场取得主动地位？是稀缺性。普通的人找工作，稀缺的人被工作找。 《认知突围》的作者问了一个问题，环卫工人的工作十分辛苦，对城市来说又极其重要，为什么他们的收入如此之低呢？ 这是因为我们的报酬，不是按劳动的辛苦程度来算，也不是按工作的重要程度来算的。单位时间的劳动价值是由供求关系决定的，我们是按能力的稀缺程度来拿报酬的。 环卫工人的工作门槛低、可替代性强，就是工作内容辛苦、工作性质重要，也无法拿到高报酬。重要和稀缺是两回事，辛苦程度和创造的价值也不一定成正比。 物以稀为贵，人也是以稀为贵。所以想找到高报酬的工作一定要修炼稀缺的能力。在能力发育的过程中，永远问自己：我是否掌握了一般人不会的技能？ 横向上，看一下哪个领域，缺口大，就业人员少？选门槛高、可替代性弱、经验值钱的专业学。 比如当医生，随着积累，经验会非常值钱，可是如果是办公室文员，经验就不太值钱，稍微一两年就是天花板。 纵向看，同样的技能，我是否比别人专研得更深、完成得更有效率？ 烂大街的“通过英语四六级考试”当然比不上“可以用英语流利地交流”，折腾一晚上只能做个平平无奇的PPT当然比不上一个小时就能做出让人惊艳的PPT。纵向的稀缺，就是把一件事做到极致。 6、关于工作： 格局小的精明，会毁掉一个人 职场里总是有一群爱横向比较、爱计较的人：同事偷懒，我为什么不能偷懒，同事拖拉，我为什么不能拖拉？一个办公室上班，凭什么我多做事？这不公平！老板就给我这么多工资，我为什么要多做事？拿固定的工资，少做点事，我就是占了老板的便宜了。 这是一种格局特别小的精明，当你发现同事里都是这样的老油条，最好赶紧离开这个公司。这种对价值的计算实在太目光短浅。 《认知突围》认为，很多人把工作当成计件奖赏、计时奖赏，这是一种很原始的折合方式。格局大的人，不会这样算，格局大的人着眼于自己的成长，着眼于自己的能力发育。那种和同事和老板看似精明的斗智斗勇，其实是职场的慢性自杀。 据说，现在每个人一辈子平均要换8-10份工作，也就是你已经很难在一个公司待一辈子。 每个公司都只是你成长的一个阶段，请尽可能地从每一份工作里汲取养分，尽可能地成长，为下一次出发积蓄力量。 7、关于努力： 别再拿“我懒”当遮羞布了 《认知突围》的作者蔡垒磊问过很多人：“你认为自己懒吗？”结果90%都认为自己懒。认为自己懒，背后的意思其实是：我可以变得更好，只不过我懒。 他认为，懒的根源其实也在于认知能力受限。就拿学习来说，因为认知不足，所以搞不清楚学习有什么用，所以看不清接受教育和未来自己想要的结果之间的强联系，所以没有做出正确的决定。 我听过一句反鸡汤的减肥语录：别老说减肥减肥，说得好像你瘦下来就不丑了。关于懒，《认知突围》也说了一句反鸡汤：别老说自己懒，老把什么都归结为自己懒，说的好像勤快就能怎么样似的。 “懒”更像一块遮羞布，就像一些差生的家长喜欢说自己的孩子：“我家孩子挺聪明的，就是懒，不肯用功。”所以就算孩子只考了十几分，也仍然可以继续当一个聪明的孩子。孩子到底聪不聪明，我们不知道，但我们知道孩子接下来的人生，都要为不肯用功承担后果。 因为懒、不肯用功所以学习差，听起来比很用功但还是学习差，似乎更体面一些。所以懒成了最好的遮羞布。 如果扯掉这块遮羞布，真实的你是一个什么样的人呢？ 25岁之前你可以理直气壮地迷茫，25岁之后有些事情拎不清，社会对你就不会那么宽容了。这些道理，你越早明白越好。 "},"article/zhihu48.html":{"url":"article/zhihu48.html","title":"知乎上的神回复","keywords":"","body":"知乎上的神回复 原文链接 1、交朋友的标准是什么？ 答：出世的智者，入世的强者，或者正常而阳光的普通人。 2、男性更看重女性的身材、脸蛋，还是思想？ 答：脸蛋和身材决定了我是否想去了解她的思想，思想决定了我是否会一票否决掉她的脸蛋和身材。 3、“别让孩子输在起跑线上”有道理吗？ 答：一辈子都要和别人去比较，是人生悲剧的源头。 4、做哪些事情可以提升生活品质？ 答：定期扔东西。 5、结婚以后两个人在一起最重要的是什么？ 答：就当这婚还没结。 6、怎么反驳“你行你上啊”的逻辑？ 答：“我评论个电冰箱，自己还得会制冷啊？” 7、把学费拿来念书还是环游世界更合适？为什么？ 答：读书在没有充分的知识作为前提的情况下，即使行了万里路也不过是邮差而已。 8、为什么部分人会产生“聪明智慧的姑娘都被憨憨的小伙儿搞定了”的印象？ 答：严肃地说，我觉得，要么姑娘只是看起来聪明，要么小伙儿只是看起来憨…… 9、你心中的完美爱情是怎么样的？ 答：可以有不完美。 10、异国长期生活，改变了你的哪些“是非观”？ 答：很多事情只是不同，并无是非。 11、是不是一个人越成熟就越难爱上一个人？ 答：不是越成熟越难爱上一个人。是越成熟，越能分辨那是不是爱。 12、如何让这个世界变得美好？ 答：把你自己变得更美好。 13、苦难有什么价值？ 答：永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。 14、如何反驳“现实点，这个社会就是这样”？ 答：“你是怎样，你的世界就是怎样。” 15、你对自由的理解是什么？ 答：说“不”的能力。 16、怎么看待励志的书籍？ 答：看再多，那都是别人的人生。 17、同样是别人比自己强，为什么有时会产生嫉妒心理，而有时会产生崇拜？ 答：远的崇拜，近的嫉妒；够不着的崇拜，够得着的嫉妒；有利益冲突的嫉妒，没利益冲突的崇拜。 18、为什么当看到好照片时人们通常的反应是“真不错，你用的是什么相机”，当看到烂照片时，则往往笑话拍摄者水平很臭？ 答：人习惯性地将自己的成功归因于自身，失败归因于环境；而将他人的成功归因于环境，失败归因于其自身。 19、怎样在有效提出推荐或建议的同时，避免给人灌输和强迫的感觉？ 答：说服他人不要诉诸理性，应求于利益。 20、哪些技能，经较短时间的学习，就可以给人的生活带来巨大帮助？ 答：夸奖他人。 21、你是如何走出人生的阴霾的？ 答：多走几步。 22、二十六岁，工作三年却将留学三年，值得吗？ 答：普通玩家选择标准配置，高端玩家选择自定义配置。 23、如何看待“年轻时就释怀与淡泊，是没有希望的”这句话？ 答：试图用一句话就来总结复杂的人生，是没有希望的。 24、要怎样努力，才能成为很厉害的人？ 答：如果你注定要成为厉害的人，那问题的答案就深藏在你的血脉里；如果你注定不是厉害的人，那你便只需要做好你自己。 25、前半生与后半生的分界线是在哪里？ 答：此时此刻。 26、你遇到过哪些让你眼前一亮、醍醐灌顶或对你改变很大的理念？ 答：天赋决定了你能达到的上限，努力程度决定了你能达到的下限。以绝大多数人的努力程度之低，远远没有达到要去拼天赋的地步。 27、人这一生为什么要努力？ 答：最痛苦的事，不是失败，是我本可以。 28、在一个足够小的星球上行走，我们是在上坡还是下坡？ 答：你感觉累就是上坡，感觉轻松就是下坡。 29、听过最落寞的一句话或诗句是什么？ 答：不如意事常八九，可与言者无二三。 30、世界上有那么多好书好电影好动漫注定看不完，我们对这个事实该持何种态度？ 答：怕什么真理无穷，进一寸有一寸的欢喜。——胡适 31、三十岁才开始学习编程靠谱吗？ 答：种一棵树最好的时间是十年前，其次是现在。 32、向喜欢的女生表白被拒绝了，还是喜欢她，怎么办？ 答：也许你弄错了什么是表白，表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。 33、省钱的好办法有哪些？ 答：在买任何东西之前牢记九字箴言：你喜欢，你需要，你适合。PS：适用于很多事，包括感情也一样。 34、王阳明的“知行合一”到底如何理解？又怎样运用到实际生活中？ 答：知道做不到，等于不知道。 35、什么叫见过大世面？ 答：能享受最好的，能承受最坏的。 36、科学和迷信的分界点是哪里？ 答：我错了。 37、扎克伯格初期是怎么保护 Facebook 的最初创意？为什么Facebook 上线后没被其他大公司抄走？ 答：保护创意的最好方法，就是将其最好地执行。 38、员工辞职最主要的原因是什么？ 答：钱少事多离家远，位低权轻责任重。 39、你在生活中得到过的最好的建议是什么？ 答：“过度自我关注是万恶之源”、“永远不要为尚未发生的事儿拧巴”、“觉得为时已晚的时候，恰恰是最早的时候”。 40、哪些行为是浪费时间？ 答：思而不学 犹豫不决。 41、最能燃起你学习激情的一句话是什么？ 答：你不能把这个世界，让给你所鄙视的人。 42、如果好人没好报，我们为什么还要做好人？ 答：我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。——哈维尔 43、恋爱半年，女朋友觉得没有了开始时的新鲜感，怎么办？ 答：所谓新鲜感，不是和未知的人一起去做同样的事情，而是和已知的人一起去体验未知的人生。 44、为什么大家都要上大学找工作，而不太喜欢开出租车、开小店、开饭馆、摆街边早餐小吃摊等“短平快”项目？ 答：“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。”——龙应台 45、情商不高的例子有哪些？ 答：对陌生人毕恭毕敬，对亲近的人随意发怒…… 46、如何看待“年轻的时候需要的是朋友而不是人脉”？ 答：没有目的之交往，才能感动人。 47、有哪些道理是你读了不信，听不进去，直到你亲身经历方笃信不疑的？ 答：不要低估你的能力，不要高估你的毅力。 48、有哪些我们熟知的名言其实还有后半句？ 答：“人是生而自由的”，下一句是：“但无往不在枷锁之中”，再下一句是：“自以为是其他一切主人的人，反而比其他一切更是奴隶。” 49、怎样控制住自己不发脾气？ 答：如果你是对的，你没必要发脾气；如果你是错的，你没资格发脾气。 50、经历多少次失败，才能找到真爱？ 答：所有的失恋都是在给真爱让路。 51、男友总说“忙”不陪我，是借口吗？ 答：想送你回家的人，东南西北都顺路；愿陪你吃饭的人，酸甜苦辣都爱吃；想见你的人，千山万水都能赶来。 52、怎样含蓄地表达「我已经被收买了」？ 答：我说句公道话… 53、为什么不能和前男友联系？ 答：感情世界里最没用的四种东西：分手后的悔恨，不爱后的关怀，高高在上的自尊心，低情商的善良。 54、为什么深海里的鱼都长得那么特别？ 答：深海里黑漆漆的，谁也看不见谁，大家就随便长长了… 54、在古代神话中，为什么柳树槐树这种植物可以成精，而水果蔬菜就不能成精？ 答：上午发愿修炼，中午就给炖了… 55、女朋友发短信说「我想你了」，应该怎么回短信才好？ 答：死脑筋啊。她发短信你就回短信？回电话啊！ 56、妹子还书的时候夹了一张面巾纸，是什么意思？ 答：说明你对人家有意思。 57、同龄人中不少人结婚生子了，对你有什么影响吗？ 答：对我没啥影响，对我妈影响比较大。 58、你们是怎么忍受孤独的？ 答：这么说吧，忍受孤独可比忍受傻逼简单多了。 59、为什么部分人友善且独来独往？ 答：待人友善是修养，独来独往是性格。 60、史书中有哪些看起来轻描淡写但品味起来很残酷的话？ 答：我们走了一些弯路…… "},"article/soft-skills.html":{"url":"article/soft-skills.html","title":"软能力","keywords":"","body":"软能力 原文链接 在我们日常工作中，常常会听到软能力这一个词汇，尤其是在称赞某个人工作表现不错的时候更是如此。然而关于软能力是什么，一百个人有一百种解释，就好像一千个人有一千个哈姆雷特。 一、软能力是什么 什么是软能力？回答这个问题之前，我们先要了解什么是硬能力。 还记得曾经如火如荼的高考吗，大家都是卯足了劲儿，挑灯夜读，为的就是上一所心仪的大学。 在应试教育的背景下，考试能力、学习成绩这些就是你的硬能力。 金庸小说里，第一次华山论剑，南帝北丐展一阳指、降龙十八掌之绝技，东邪西毒现弹指神通、蛤蟆功之怪诞武艺，最终由中神通王重阳战胜群雄，获得天下第一。 在武侠小说里，武功的高低是你的硬能力。 硬能力往往最容易被记住，而且人们也更乐于就某个人物(或事物)的硬能力进行谈论 为什么？因为相对于软能力来说，硬能力更加简单，更容易被描述。 那么，软能力究竟应该对应什么？ 在高考评估体系里面，占比重最大的无非是笔试成绩，而一些实用型能力比如沟通能力、组织协调能力却没能被考虑进去(这是国内应试教育一直被诟病的地方)，它们是组成软能力的重要部分。 再看看华山论剑的案例，武功再高，如果品行败坏，坏事做尽，是很难获得后人世颂的。这时，武德便是一种软能力。另外，如果武艺高强却没有人知道，就是隐姓埋名；说不中听的，那就是废柴一个。 这时候，名号的传播就很重要了，我们知道，大约宋代开始，有一种说书人，其常年以演说卖艺为生。在现如今，这便是隐形的营销。 有人说，在当今的世界上，硬能力就是智商，软能力则是情商；也有人说，在企业里面，硬能力是满足岗位需求的必要技能，软能力是你与团队进行交互协作的能力。 我觉得，说的都对！软能力是能够让你变得优秀的关键能力。 二、软能力-程序猿生存指南 让我们回到 软件开发 这个行当，当你即将成为一名程序猿，或者你已经作为程序猿好多年了之后，你是否清楚： 作为一名程序猿，应该至少具备什么样的软能力，才能使你从猿猿众生中脱颖而出。 在《软技能-代码之外的生存指南》一书中，作者约翰 Z. 森梅兹为以自己的经历为例，为我们仔细讲述了程序员除了写代码之外应该具备的各种软能力，值得一提的是，该作者还是一名出色的健身爱好者及投资客，这可能是令许多人望尘莫及的。 摘序 作为一个软件开发人员，在我的生活中，我经历过许多不同的旅程。 我曾走在阳关大道，也曾误入歧途，还有一些路我至今仍不知是对还是错。 这一路走来，我并没有得到太多的帮助和指导。 我从来没觉得有谁为我披荆斩棘，开辟出一条小路使我可以因循， 也从来没觉得有谁可以告诉我如何成为一名最成功的软件开发人员—— 不能只编写代码，还要有精彩的人生。 在阅读完此书后，我将所能记住的软能力归纳如下： 好了，有点多.. 有了这些技能，相信大部分程序猿就能迎娶白富美，走上人生巅峰了吧！ 为了简化理解，我们可以将关注点聚焦到下面几个维度上： 接下来解读一下 A. 沟通能力 关于沟通方面的能力是老生常谈了，沟通表达能力强的程序猿总是不一样，在很多场景下都会占优： 小组选拔带头人 出差到客户现场露露脸 介绍对象... 沟通好的人有一点很关键的是换位思考能力，就是能为沟通的对象着想，让你感觉很舒服。下面有个案例： B. 学习能力 学习要有方法，才能取得更高的效率及更好的效果。在《软技能-代码之外的生存指南》一书中提到的 \"十步学习法\" 如下： 第一步：了解全局 第二步：确定范围 第三步：定义目标 第四步：寻找资源 第五步：创建学习计划 第六步：筛选资源 第七步：开始学习，浅尝辄止 第八步：动手操作，边玩边学 第九步：全面学习，学以致用 第十步：乐为人师，融会贯通 十步学习法看似有些繁琐，其实却很有逻辑性，是一个循序渐进的过程。经过归纳后，我们当然可以做一些简化。 这里以学习spring cloud为例，整个过程如下： 当然，关于学习过程，你可以自己归纳，但不应该是没有章法的。 C. 时间管理 时间管理，在职场上更多的是工作管理，即如何有条不紊的将工作逐个完成，既要满足上级，也要让自己不纠结后悔。 许多关于时间管理的书籍都会提到番茄工作法 如下 按照 番茄钟 的方式对工作任务进行拆解排序； 每个番茄钟对应一段25分钟的工作时间； 在每个番茄钟内部不允许有新任务插入，此时只需要将任务放到待办事项； 每个番茄钟结束后，进行5分钟的休息调整，之后进行下一个番茄钟 在进行事务排序时，推荐使用四象限法 番茄工作法是不错的，但并不完美，许多人尽管知道但却很做到极致。比如： 很难将任务优先级进行排序，万一错了呢？ 很难将任务对应到25分钟内，我其实需要1个小时.. 很难拒绝新来的任务啊，面对主管的催促，运营MM的询问，实在纠结 针对这些问题，你只能先承受着..，然后不断去尝试优化 李笑来在《和时间做朋友》专栏中提出一个观点：时间是不可管理的！ 这说的倒是没错，我们其实都是时间的奴隶(尽管有些消极)。所以，需要知道失控是一种常态，以一种平稳的心态去看待。在过程中去找到你真实的现状和能力，持续探索属于自己的控制方式。 D. 分解能力 分解能力几乎是各个领域里最通用的能力了。这个世界是结构化的，大到一个庞大的帝国，小到一只蝼蚁，都是由结构组成的。就连本文都有一个相对不那么模糊的提纲结构。 在软件世界里也一直推崇分而治之的思想。技术人只有具备了良好的结构思考力，在应付一个庞大的项目时才能显得得心应手。 至于这种先总后分 的结构化思维方式，也是一直传承以久的。 这里推荐一本书籍，叫《结构化思考力》，作者李忠秋是专注于该领域的专家。将这部书多读两遍，相信会有所收获。 E. 总结改进 总结归纳是一种能力，但更应该成为一种习惯。总结的目的是为了改进，刷新自我。 在《高效人士的七个习惯》中，第七条就是 “不断更新 平衡的自我更新原则” 有不少企业将总结改进作为团队管理的核心要领之一，在敏捷化项目管理中，迭代回顾也是重要形式之一。但是呢，对于大部分程序猿个人来说，做总结改进可能有些痛苦。 “有那么多时间做总结，还不如多敲点代码！” 以上，如果代表了你的心声，那么很遗憾，这只是你给自己找的关于不愿意进步的一个借口。 三、程序猿成长路线 软能力在程序猿的成长中其实扮演了至关重要的角色，但往往只是不被察觉 通常，一名程序猿的发展道路有许多种，如下图所示： 其中，架构师、项目经理、产品经理是出镜率最高的，大多只要是不跨行的程序猿，几乎最后都是如此。而对于我而言，这几个角色又是特别熟悉不过的。 问题：软能力于这些角色又有什么样的关系？ 1. 架构师 微服务架构很火，架构师的职位也很火，程序猿看到架构师 21天 快速进阶的字眼也很兴奋... 然而比较遗憾的是，许多关于架构师的培训、书籍都是以架构技术为主，认为架构师就是技术牛B就好，对于架构师的软能力一概不谈。 一些初创型的公司中，创始人并不真正了解架构师，却执着于招聘架构师岗位，素不知道他只是需要一个高级码农就可以了.. 下面这个图来自《软件架构师的12项修炼》一书，很好的说明了架构师该具备的软技能。 see? 技术能力只是最基础的部分，沟通、领导力、认知、创新等等却是属于更高阶的能力。 2. 项目经理 项目经理是一种纯管理类的岗位，在大部分中小型公司里，项目经理更多扮演了一个\"打杂\"的角色。为什么？ 我们先来看看项目经理的担子有多重： 目标管理要团队的每个人都能理解目标，非强大的沟通能力不可。 进度管理天天早会，天天监工，烦不胜烦.. 成本管理至少有一点成本预算意识(投资意识)，小心老板对你不满！ 人员管理有些人不想干了，得找他谈谈心，或许还有挽留的机会.. 风险管理总是提心吊胆，得有强大的心理素质 ... 也确实，好的项目经理身上总是聚集了许多高超的软能力，然而并不是很多程序猿都想当项目经理。一般来说，没有技术情结或技术不到家的，想快速上位的，可以走这个路线。 3. 产品经理 程序猿转型产品经理的案例现在也越来越多了，这说明什么？ 互联网渗透率在加速的涨，产品经理待遇也在涨.. 具备技术背景的产品经理无疑是有优势的，但只是要小心，不要掉进技术情结的怪圈 对于胜任产品经理一事的能力诉求，我认为下面的一张图可以很好说明： 【图来自豆瓣：https://www.douban.com/note/321706416/】 在上面的图示中，沟通协调能力、逻辑分析、学习能力等等都在前面篇幅中提及。可见，在转型产品经理一职之前，程序猿要升华的部分仍然是不少！ 四、小结 笔者在接触软件工作的这些年间，接触过不少程序猿，大部分人天资聪慧，热情助人，以拯救大家为己任。但是在面临职业生涯瓶颈转折之时，往往会产生许多纠结。技术出众者往往孤傲，不善于合群；技术平平者，往往能说会道，职场之路畅行无阻！ 在大部分情况下，软能力是获得成功的关键，本文介绍了一些模型，希望对读者能产生一些启示。谨以此文，献给仍然在挣扎中奋斗的技术人！ "},"article/oldTechnologyArticle/ThinkPHP_template.html":{"url":"article/oldTechnologyArticle/ThinkPHP_template.html","title":"ThinkPHP 模板中的语法知识","keywords":"","body":"ThinkPHP 模板中的语法知识 原文链接 一、导入CSS和JS文件（记住常量的是大写） css=>link 、js=>script import（默认是在Public文件夹下） //导入Public文件夹下面的Js目录中的test.js文件，import标签可以省略type属性，默认就是js的 //可以更改默认文件夹 设置basepath属性 //就会在 根目录下找到 Other/Js/my.js,就不是默认的Public目录 load //方法可以自动检测导入的文件类型 二、分支结构 if (一定要注意 else 或 elseif 后面的 /) 男人哭吧哭吧不是罪！ 做女人挺好的！ 未成年 奋斗吧少年！ 成年 // 下面是判断语法 > gt = egt != neq === heq !== nheq //变量不要加 $ 直接名字myAge 默认会加$ 太小啦你 你也太小 你还差不多 这里是默认值 三、循环结构 for /* start（必须）：循环变量开始值 end（必须）：循环变量结束值 name（可选）：循环变量名，默认值为i step（可选）：步进值，默认值为1,自加！ comparison（可选）：判断条件，默认为lt */ {$j}abc //倒序 {$j}abc volist（数组遍历） {$v.username} //从下表=1的开始取2条 //遍历多维数组 -- foreach {$k}-------{$v} 四、特殊标签 比较标签 eq或者 equal 等于 模板中等同于if else的使用 number传的变量 如果传的name=10我就输出这里也！ 不等于10我就输出这里哦！ neq 或者notequal 不等于 gt 大于 egt 大于等于 lt 小于 elt 小于等于 heq 恒等于 nheq 不恒等于 范围标签(类似if else逻辑和书写方式) in 标签 在这些数字里面 不在这些数字的范围内 notin 标签 在这些数字里面 不在这些数字的范围内 between 标签 //1-10之间 {$number}在1-10之间 {$number}不在1到10之间 notbetween 标签 来判断变量不在某个范围内 输出内容1 present 标签 标签来判断模板变量是否已经赋值 m有赋值m没有赋值 Empty 标签 empty标签判断模板变量是否为空 number为空赋值number有值 Defined 判断常量是否已经定义 Define 在模板中定义常量 Assing 在模板中给变量赋值 五、其他标签使用 在模板中直接使用PHP代码 echo \"Hello World\" //注意里面只能写php的代码，嵌入tp的标签是不能用的 建议更改左右定界符 在配置文件中改变 'TMPL_L_DELIM'=>''}>', //修改右定界符 "},"article/oldTechnologyArticle/zifubianma.html":{"url":"article/oldTechnologyArticle/zifubianma.html","title":"字符编码趣闻","keywords":"","body":"ASCII、Unicode、GBK和UTF-8字符编码的区别联系 知乎链接 原文链接 很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机“。 开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0×10, 终端就换行，遇上0×07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空 格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉 很好，于是大家都把这个方案叫做ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用 127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128 到255这一页的字符集被称”扩展字符集“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ 等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。 但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣 们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……” 因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！ 正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。 unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符“！同时，也都是统一的”两个字节“，请注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 unicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。 unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。 UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） —————————————————————– 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx "},"article/oldTechnologyArticle/email.html":{"url":"article/oldTechnologyArticle/email.html","title":"Outlook邮件模板踩坑","keywords":"","body":"邮件模板采坑 Outlook客户端： 不支持HTML5 Outlook支持传统的table 布局，不支持浮动，定位布局，建议使用table布局。 内部和外联样式表实际操作来看，Outlook2010是支持的，但是慎用，不排除低版本Outlook不支持，建议写内联样式。 表格正常布局，建议格式化样式，合并内边距cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse: collapse;\"，建议开发时border=\"1\",这样可以看到你当前布局所占的位置，方便调试。 table对于margin支持不好，padding实际操作可以。两个部分之间的空格建议新建一行tr空元素加高度实现。 实际操作中line-height会解析错误，直接给高度也可以实现垂直居中。 浮动可以使用align=\"center/left/right\"。 使用colspan，rowspan可以正确解析，合并表格 图片问题尽量使用在线的路径，注意使用线上绝对路径的src值，防止图片找不到。图片设置width属性，写在style中可能会不生效。 table支持背景色和text-align:center;文字居中 英文不自动换行，可以使用 Outlook的Web客户端 跟以上的不同点是，不支持内部和外联样式表，所以只能用内嵌，内嵌的覆盖样式在预览状态下不支持，会被客户端的一些标签给替换掉，比如说英文换行，双击新页面打开可以正常展示 图片展示需要开始受信任人才可以展示 "}}